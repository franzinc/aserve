<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
  <meta http-equiv="content-type"
 content="text/html; charset=ISO-8859-1">
  <title>AllegroServe</title>
  <meta name="GENERATOR" content="Microsoft FrontPage 3.0">
</head>
<body>
<table border="0" cellpadding="1" cellspacing="0" width="100%">
  <tbody>
    <tr>
      <td colspan="2" bgcolor="#00ffff">
      <table border="0" cellpadding="5" cellspacing="3">
        <tbody>
          <tr>
            <td bgcolor="#00ffff" align="left"> <a
 href="http://www.franz.com/support/documentation/current/doc/contents.htm"><b>ToC</b></a></td>
            <td bgcolor="#00ffff" align="left"> <a
 href="http://www.franz.com/support/documentation/current/doc/introduction.htm"><b>DocOverview</b></a></td>
            <td bgcolor="#00ffff" align="left"> <a
 href="http://www.franz.com/support/documentation/current/doc/cgide.htm"><b>CGDoc</b></a></td>
            <td bgcolor="#00ffff" align="left"> <a
 href="http://www.franz.com/support/documentation/current/doc/release-notes.htm"><b>RelNotes</b></a></td>
            <td bgcolor="#00ffff" align="left"> <a
 href="http://www.franz.com/support/faqs/"><b>FAQ</b></a></td>
            <td bgcolor="#00ffff" align="left"> <a
 href="http://www.franz.com/support/documentation/current/doc/index.htm"><b>Index</b></a></td>
            <td bgcolor="#00ffff" align="left"> <a
 href="http://www.franz.com/support/documentation/current/doc/permuted-index.htm"><b>PermutedIndex</b></a></td>
          </tr>
        </tbody>
      </table>
      </td>
    </tr>
  </tbody>
</table>
<h1 align="center">AllegroServe - A Web Application Server<br>
<small><small><small>version <font face="Courier New">1.3.4</font></small></small></small></h1>
<p align="left"><strong><small>copyright(c) 2000-2011. Franz Inc</small></strong></p>

<p>
AllegroServe is available for download as part of Allegro CL (see <a
 href="http://www.franz.com/">www.franz.com</a>) or
 at <a href="https://github.com/franzinc/aserve/">https://github.com/franzinc/aserve/</a>. See <a
 href="http://www.franz.com/support/documentation/current/doc/aserve/aserve.html">www.franz.com/support/documentation/current/doc/aserve/aserve.html</a> for the latest available version of this document.
</p>
<h2 align="left">Table of Contents</h2>
<p align="left"><a href="#introduction">Introduction</a><br>
<a href="#running-AllegroServe">Running AllegroServe</a><br>
<a href="#starting-the-server">Starting the Server</a><br>
<font face="Courier New">&nbsp; <a href="#f-start">start</a></font><br>
<a href="#shutting-down-the-server">Shutting Down the Server</a><br>
<font face="Courier New">&nbsp; <a href="#f-shutdown">shutdown</a></font><br>
<a href="#publishing-information">Publishing Information</a><br>
<font face="Courier New">&nbsp; <a href="#f-publish-file">publish-file</a><br>
&nbsp;&nbsp;&nbsp; </font><a href="#entity-hook-function">Entity hook
function</a><font face="Courier New"><br>
&nbsp; <a href="#f-publish-directory">publish-directory</a><br>
&nbsp;&nbsp; </font>&nbsp; <a href="#directory-access-files">Directory
Access
Files</a><font face="Courier New"><br>
&nbsp; <a href="#f-publish">publish</a></font><br>
&nbsp;&nbsp;&nbsp; <font face="Courier New"><a href="#f-publish-prefix">publish-prefix</a></font><br>
&nbsp;&nbsp;&nbsp; <a href="#f-publish-multi"><font face="Courier New">publish-multi</font></a><br>
<a href="#generating-a-computed-response">Generating a Computed Response</a><br>
<font face="Courier New">&nbsp; <a href="#f-with-http-response">with-http-response</a><br>
&nbsp; <a href="#f-with-http-body">with-http-body</a><br>
&nbsp; <a href="#f-get-request-body">get-request-body</a><br>
&nbsp; <a href="#f-header-slot-value">header-slot-value</a><br>
&nbsp; <a href="#f-reply-header-slot-value">reply-header-slot-value</a><br>
&nbsp; <a href="#f-request-query">request-query</a></font><br>
&nbsp;&nbsp;&nbsp; <font face="Courier New"><a
 href="#f-request-query-value">request-query-value</a><br>
</font><a href="#request-variables">Request Variables</a><font
 face="Courier New"><br>
&nbsp; <a href="#f-request-variable-value">request-variable-value</a><br>
</font>
<a href="#request-object-readers">Request Object Readers and Accessors</a><br>
<font face="Courier New">&nbsp; <a href="#f-request-method">request-method</a><br>
&nbsp; <a href="#f-request-uri">request-uri</a><br>
&nbsp; <a href="#f-request-protocol">request-protocol</a><br>
&nbsp; <a href="#f-request-socket">request-socket</a><br>
&nbsp; <a href="#f-request-wserver">request-wserver</a><br>
&nbsp; <a href="#f-request-raw-request">request-raw-request</a><br>
&nbsp; <a href="#f-request-reply-code">request-reply-code</a><br>
&nbsp; <a href="#f-request-reply-date">request-reply-date</a><br>
&nbsp; <a href="#f-request-reply-headers">request-reply-headers</a><br>
&nbsp; <a href="#f-request-reply-content-length">request-reply-content-length</a><br>
&nbsp; <a href="#f-request-reply-plist">request-reply-plist</a><br>
&nbsp; <a href="#f-request-reply-strategy">request-reply-strategy</a><br>
&nbsp; <a href="#f-request-reply-stream">request-reply-stream</a></font><br>
<a href="#cgi-program">CGI Program Execution</a><br>
<font face="Courier New">&nbsp; <a href="#f-run-cgi-program">run-cgi-program</a><br>
</font><a href="#form-processing">Form Processing</a><br>
<font face="Courier New">&nbsp; <a href="#f-get-multipart-header">get-multipart-header</a><br>
&nbsp; <a href="#f-parse-multipart-header">parse-multipart-header</a><br>
&nbsp; <a href="#f-get-multipart-sequence">get-multipart-sequence</a></font>
<br>
&nbsp;&nbsp;&nbsp; <a href="#f-get-all-multipart-data"><font
 face="Courier New">get-all-multipart-data</font></a><br>
&nbsp;&nbsp;&nbsp; <font face="Courier New"><a
 href="#f-form-urlencoded-">form-urlencoded-to-query</a><br>
&nbsp; <a href="#f-query-to">query-to-form-urlencoded</a></font><br>
<a href="#authorization">Authorization</a><br>
<font face="Courier New">&nbsp; <a href="#f-get-basic-authorization">get-basic-authorization</a><br>
&nbsp; <a href="#f-set-basic-authorization">set-basic-authorization</a><br>
&nbsp; <a href="#c-password-authorizer">password-authorizer</a><br>
&nbsp; <a href="#c-location-authorizer">location-authorizer</a></font><br>
&nbsp;&nbsp;&nbsp; <a href="#c-function-authorizer"><font
 face="Courier New">function-authorizer</font></a><br>
<a href="#cookies">Cookies</a><br>
<font face="Courier New">&nbsp; <a href="#f-set-cookie-header">set-cookie-header</a><br>
&nbsp; <a href="#f-get-cookie-values">get-cookie-values</a></font><br>
<a href="#varaibles">Variables</a><br>
&nbsp;&nbsp;&nbsp;&nbsp; <font face="Courier New"><a
 href="#v-aserve-version">*aserve-version*</a><br>
&nbsp; <a href="#v-default-aserve-external-format">*default-aserve-external-format*</a><br>
&nbsp; <a href="#v-http-response-timeout">*http-response-timeout*</a><br>
&nbsp; <a href="#v-mime-types">*mime-types*</a></font><br>
<a href="#iseve-request-proc">AllegroServe Request Processing Protocol<br>
</a><font face="Courier New">&nbsp; <a href="#f-handle-request">handle-request</a><br>
&nbsp; <a href="#f-standard-locator">standard-locator</a><br>
&nbsp; <a href="#f-unpublish-locator">unpublish-locator</a><br>
&nbsp; <a href="#f-authorize">authorize</a><br>
&nbsp; <a href="#f-failed-request">failed-request</a><br>
&nbsp; <a href="#f-denied-request">denied-request</a><br>
&nbsp; <a href="#f-process-entity">process-entity</a></font><br>
<a href="#client-request">Client Functions</a><br>
<font face="Courier New">&nbsp; <a href="#f-do-http-request">do-http-request</a><br>
&nbsp; <a href="#c-client-request">client-request</a><br>
&nbsp; <a href="#c-cookie-jar">cookie-jar</a><br>
&nbsp; <a href="#f-make-http-client-request">make-http-client-request</a><br>
&nbsp; <a href="#f-read-client-response">read-client-response-headers</a><br>
&nbsp; <a href="#f-client-request-read-sequence">client-request-read-sequence</a><br>
&nbsp; <a href="#f-read-response-body">read-response-body</a><br>
&nbsp; <a href="#f-client-request-read-close">client-request-close</a><br>
&nbsp; <a href="#f-compute-digest-authorization">compute-digest-authorization</a><br>
&nbsp; <a href="#f-uriencode-string">uriencode-string</a></font><br>
<a href="#proxy">Proxy</a><br>
<a href="#cache">Cache</a><br>
<a href="#filters">Request Filters</a><br>
<a href="#virtual_hosts">Virtual Hosts</a><br>
<a href="#timeouts">Timeouts</a><br>
<font face="Courier New">&nbsp; <a href="#f-wserver-io-timeout">wserver-io-timeout</a><br>
&nbsp; <a href="#f-wserver-response-timeout">wserver-response-timeout</a></font><br>
<a href="#compression">Compression</a><br>
<a href="#ssltls">SSL/TLS</a><br>
<a href="#miscellaneous">Miscellaneous</a><br>
&nbsp;&nbsp;&nbsp;&nbsp; <font face="Courier New"><a
 href="#f-ensure-stream-lock">ensure-stream-lock</a></font><br>
&nbsp;&nbsp;&nbsp;&nbsp; <a href="#f-map-entities"><font
 face="Courier New">map-entities</font></a><br>
&nbsp;&nbsp;&nbsp;&nbsp; <a href="#f-log-for-wserver"><font
 face="Courier New">log-for-wserver</font></a><br>
<a href="#asaservice">Running AllegroServe as a Service on Windows NT</a><br>
<a href="#international-chars-aserve">Using International Characters in
AllegroServe</a><br>
<a href="#debugging">Debugging</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-family: Courier New;"><span
 style="text-decoration: underline;"></span></span><font
 face="Courier New"><a href="#f-debug-on">net.aserve::debug-on</a><br>
&nbsp; <a href="#f-debug-off">net.aserve::debug-off</a></font><br>
<br>
<br>
</p>
<h2 align="left">In<a name="introduction"></a>troduction</h2>
<p><strong>AllegroServe</strong> is a webserver&nbsp; written at <a
 href="http://www.franz.com">Franz Inc</a>.&nbsp;&nbsp;AllegroServe is
designed to work
with the <a href="htmlgen.html">htmlgen</a> system for generating
dynamic html, as one of
the big advantages of&nbsp; a web server written in Common Lisp is the
ability to generate
html dynamically.&nbsp; In this document we'll consider the web server
and dynamic html
generation to be parts of the same product.</p>
<p>The design goals of AllegroServe are: </p>
<ul>
  <li>a very small footprint.&nbsp;&nbsp; It should be possible to make
AllegroServe a part of every application without being concerned about
the impact of its size and processing requirements.</li>
  <li>simple configuration.&nbsp; AllegroServe should start
automatically with minimal input from the user.&nbsp; </li>
  <li>easy to use.&nbsp;&nbsp; The typical scenarios should be easy to
program with just knowledge of simple html.</li>
  <li>usable in commercial applications .</li>
  <li>support the latest http protocol (currently HTTP/1.1)</li>
  <li>runnable in multiple configurations.&nbsp;&nbsp;&nbsp; We want to
support a program that just wants to make some part of it visible or
configurable by one user through a web server.&nbsp; We also want to
support&nbsp; a web site running on a multiprocessor taking many hits
per second.&nbsp;&nbsp; Finally, we want to support levels in between
those scenarios.</li>
</ul>
The links in the navigation bar above are to the documentation of the
latest release of Allegro CL.&nbsp; AllegroServe is supported on
earlier releases. See <a
 href="http://www.franz.com/support/documentation/">www.franz.com/support/documentation/</a>
for links to documentation of earlier releases. 
<p>&nbsp;</p>
<h2><a name="running-AllegroServe"></a>Running AllegroServe</h2>
<p>Running&nbsp; AllegroServe requires that you </p>
<ul>
  <li><strong>load</strong> <em>aserve.fasl</em> into Lisp</li>
  <li><strong>publish </strong>zero or more urls</li>
  <li><strong>start</strong> the server</li>
  <li><strong>publish </strong>zero or more urls</li>
</ul>
<p>We mention <strong>publish</strong> twice to emphasize that you can
publish urls before
and after you start the server.</p>
<p>&nbsp;</p>
<h2><a name="starting-the-server"></a>Starting the server</h2>
<p>The function <font face="Courier New">net.aserve:start</font> is
used to start the
server running.</p>
<p><strong><font face="Courier New"><a name="f-start"></a>(start
&amp;key port host
listeners chunking keep-alive server setuid setgid <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
debug proxy proxy-proxy
cache restore-cache accept-hook ssl ssl-password<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
os-processes
external-format compress<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
ssl-key ssl-password ssl-method ca-file ca-directory verify max-depth)</font></strong></p>
<p>If no arguments are given then <strong>start</strong>&nbsp; starts
a multi-threaded web
server on port 80, which is the standard web server
port.&nbsp;&nbsp;&nbsp; If you are
running this on Unix then you can only allocate port 80 if you are
logged in as root or
have made Lisp a set-user-id root program.</p>
<p>There are quite a few keyword arguments to <strong>start</strong>,
but in practice you
only need be concerned with <strong>:port</strong> and <strong>:listeners.
&nbsp;&nbsp;&nbsp;
</strong>The arguments have the following meanings:
</p>
<ul>
  <li><span style="font-weight: bold;">port</span> -- the port on which
to open the web server.&nbsp; 80 is the
default.</li>
  <li><span style="font-weight: bold;">host</span> -- the host on which
to run the server.&nbsp; If you don't
specify this then the server will listen on all TCP/IP network
interfaces on the machine.&nbsp;&nbsp; If you specify "localhost" then
the server will only accept connections from the same
machine.&nbsp;&nbsp; Other values for host can be used to run
AllegroServe only a particular network interface.&nbsp; Host can be a
name (like "foo.franz.com"), a dotted ip address "192.168.0.1" or an
integer IP address.</li>
  <li><span style="font-weight: bold;">listeners</span> -- the number
of threads to process http
requests.&nbsp;&nbsp;&nbsp;&nbsp; If a value isn't given for the <strong>:listeners</strong>
argument then 5 is assumed. &nbsp; If&nbsp; the value is <strong>nil </strong>or









    <strong>0 </strong>then the server runs in <em>simple server mode<strong>
    </strong></em>in which the <strong>start</strong> function doesn't
return - instead it processes the requests itself, one at a time.&nbsp;
If a positive number is given as the value of <strong>:listeners</strong>
then the server runs in <em>threaded server mode<strong>.</strong></em><strong>
    </strong>&nbsp; In this mode separate lisp lightweight processes
are started to handle requests from clients, the number of request
handling threads is equal to the value of the <strong>:listeners</strong>
keyword argument.&nbsp; In this mode the <strong>start </strong>function
returns
after
starting
the
other
threads.</li>
  <li><span style="font-weight: bold;">chunking</span> -- if true then
the server will use the chunked transfer
encoding when it's possible to do so.&nbsp; This is an optimization and
should be left enabled unless you suspect that it is the cause of some
sort of error.&nbsp;&nbsp; The default is true.</li>
  <li><span style="font-weight: bold;">keep-alive</span> -- if true
then the server will keep connections alive
if requested by the web client, and if there are sufficient free
threads to handle new requests coming in. &nbsp;&nbsp; This is an
optimization and should be left on.&nbsp;&nbsp; The default is true.</li>
  <li><span style="font-weight: bold;">server</span> -- if this is
passed a value it must be a <strong>wserver</strong>
object, which denotes&nbsp; a particular instance of a web
server.&nbsp;&nbsp; This is for support of running multiple independent
web servers in the same lisp image.&nbsp; This will be described in a
later section (eventually).</li>
  <li><span style="font-weight: bold;">setuid</span> -- after opening
the port, change the user id of this
process to the given number (only numbers are allowed, not
names).&nbsp; This will only have an effect on Unix and it will only
succeed if the current user id is <strong>root</strong>.&nbsp;&nbsp;
You would want to use this argument if you plan on opening port <strong>80</strong>
on Unix, as you would have to start the server as <strong>root</strong>
but then would want to change the user id to an account with fewer
privileges before allowing possibly malicious people to connect to it.</li>
  <li><span style="font-weight: bold;">setgid</span> -- after opening
the port, change the group&nbsp; id of
this process to the given number (only numbers are allowed, not
names).&nbsp; This will only have an effect on Unix</li>
  <li><span style="font-weight: bold;">debug</span> -- if given a
number this will print debugging messages
whose associated codes are this number or less.&nbsp;&nbsp;&nbsp; This
is really an internal switch and may be removed in future versions.</li>
  <li><span style="font-weight: bold;">proxy</span> -- if true then
this server will also act as a proxy server
and will forward http requests to other servers.</li>
  <li><span style="font-weight: bold;">proxy-proxy</span> -- if <strong>proxy</strong>
is also given a true
value, then this argument determines where the proxy will forward&nbsp;
requests.&nbsp; If proxy-proxy is nil then the requests go directly to
the server given in the request.&nbsp; If proxy-proxy is given&nbsp; a
value of a host and an optional port then the request is forwarded to
the proxy server at that address.&nbsp;&nbsp; Valid values for
proxy-proxy look like "proxy.myfirm.com" and
"localhost:8000".&nbsp;&nbsp; If no port is&nbsp; specified, port 80 is
assumed.</li>
  <li><span style="font-weight: bold;">cache</span> -- if true (and if
proxy is true as well) cache locally the
work done by the proxy server.&nbsp; The value of this variable
specifies the size of the caches, both memory and disk.&nbsp; See the
section on caches for more details on the format of the argument.</li>
  <li><span style="font-weight: bold;">restore-cache</span> - if given
a value then this value should be the
name of the file created by <strong>net.aserve:shutdown</strong> when
given the <strong>save-cache</strong> argument.&nbsp;&nbsp; The state
of the cache is restored as of when it was saved. &nbsp;&nbsp; This
will only succeed if the external cache files that were in use when the
    <strong>shutdown</strong> was done are in exactly the same state
they were when the <strong>shutdown </strong>was done.&nbsp;&nbsp;
When the <strong>restore-cache</strong> argument is given, the value
of the <strong>cache </strong>argument is ignored.</li>
  <li><span style="font-weight: bold;">accept-hook</span> -- this
should be a function of one argument, the
socket which was created when a http request was accepted by
AllegroServe.&nbsp; The function should return a socket for
AllegroServe to use.&nbsp; This hook is normally used to turn a regular
socket into an SSL socket.</li>
  <li><span style="font-weight: bold;">ssl</span> - if true then it
should be the name of PEM encoded file
containing the server certificate and the associated private key.&nbsp;
This causes the server to listen for SSL connections only.&nbsp; The
default value of <strong>port</strong> is made 443 (rather than
80).&nbsp; This makes use of the <strong>accept-hook</strong> argument
so if <strong>ssl</strong> is specified then <strong>accept-hook</strong>
should not be specified.&nbsp;&nbsp; ssl is supported only in certain
versions of Allegro CL.</li>
  <li><span style="font-weight: bold;">ssl-password</span> - if the
private key in the PEM encoded file
referenced by the <strong>ssl</strong> argument is encrypted, then
this is the key to decrypt it.</li>
  <li><span style="font-weight: bold;">ssl-method</span> - see <a
 href="#ssltls">SSL/TLS</a> for the use of this argument.<br>
  </li>
  <li><span style="font-weight: bold;">os-processes</span> - if given
it should be an integer number of
operating system processes in which to run AllegroServe.&nbsp; This is
available on Unix only at the moment.&nbsp; The AllegroServes in
different processes do <strong>not</strong> share a common Lisp heap..
&nbsp; </li>
  <li><span style="font-weight: bold;">external-format</span> - If
given it should name the value to which
*default-aserve-external-format* should be bound to when requests are
processed.&nbsp; The default value is<strong> :latin1-base</strong></li>
  <li><span style="font-weight: bold;">compress</span> - if true then
the server will send the body gzip compressed if the client can accept
it and the entity being returned is enabled for compression.<br>
  </li>
  <li><span style="font-weight: bold;">ssl-key</span>, <span
 style="font-weight: bold;">ssl-password</span>, <span
 style="font-weight: bold;">ca-file</span>, <span
 style="font-weight: bold;">ca-directory</span>, <span
 style="font-weight: bold;">verify</span> and <span
 style="font-weight: bold;">max-depth</span> - these values are passed
to <span style="font-weight: bold;">make-ssl-server-stream</span>
(documented with the ACL documentation) should the <span
 style="font-weight: bold;">ssl</span> argument be given.&nbsp;&nbsp; <span
 style="font-weight: bold;">ssl-key</span> is passed as the value of
the <span style="font-weight: bold;">:key</span> argument and <span
 style="font-weight: bold;">ssl-password</span> is passed as the value
of the <span style="font-weight: bold;">:certificate-password</span>
argument to <span style="font-weight: bold;">make-ssl-server-stream</span>.&nbsp;&nbsp;&nbsp;
These
value
are
only
used
in
a
fully
patched
ACL 8.0 (or newer).&nbsp;
In older versions of ACL these values are ignored.&nbsp; By specifiying
these values you can have more control on how the server does SSL
certificate managment.<br>
  </li>
</ul>
<p>&nbsp;</p>
<h2><a name="shutting-down-the-server"></a>Shutting down the server</h2>
<p><strong><font face="Courier New"><a name="f-shutdown"></a>(shutdown
&amp;key server
save-cache)</font></strong></p>
<p>This shuts down the web server given (or the most recently started
web server if no
argument is passed for <strong>server</strong>).&nbsp; If <strong>save-cache</strong>
is
given then it should be the name of a file to which the current state
of the proxy cache
will be written.&nbsp;&nbsp; The <strong>save-cache</strong> file will
only contain
in-memory information about the cache.&nbsp; The cache usually consists
of disk files as
well and in order to maintain the complete state of the cache these
files must be saved by
the user as well.&nbsp; The information in the <strong>save-cache</strong>
file refers to
the disk cache files so those disk cache files must exist and be in the
same state and
location should the user choose to restore the state of the cache.</p>
<p>&nbsp;</p>
<h2><a name="publishing-information"></a>Publishing information</h2>
<p>Once the server is started it will accept requests from http
clients, typically web
browsers.&nbsp;&nbsp; Each request is parsed and then AllegroServe
searches for an object
to handle that request.&nbsp;&nbsp; That object is called an <strong>entity</strong>.&nbsp;
If
an
entity
is
found,
it
is
passed
the
request and is responsible for
generating and
sending a response to the client.&nbsp; If an entity can't be found
then AllegroServe
sends back a response saying that that request was invalid.</p>
<p><em>Publishing</em> is the process of creating entities and
registering them in the
tables scanned by AllegroServe after a request is read.</p>
<h3>Components of a request</h3>
<p>A request from an http client contains a lot of information.&nbsp;
The two items that
determine which entity will handle the request are </p>
<ul>
  <li>the <strong>path</strong> of the url.&nbsp; This is the part of
the url after the host name and before the query string (if any).&nbsp;
For example in the url&nbsp; <font color="#0080ff"><u><strong>http://bar.com:8030/files/foo?xx=3&amp;yy=4</strong></u></font>
the part we call the path&nbsp; is just <strong><font color="#0080ff">/files/foo</font>.<br>
If </strong>the path contains escaped characters (e.g. /foo%20bar)
then we replace the %xx in the path with the actual character before
processing the request.&nbsp; Thus if you're publishing an entity to
handle a uri such as <font color="#0080ff"><u><strong>http://www.machine.com/foo%20bar</strong></u></font>
you should publish the path <strong>"foo bar"</strong> and <em>not</em>
    <strong>"foo%20bar"</strong>.</li>
  <li>the <strong>host</strong> to which the request is
directed.&nbsp;&nbsp; This is not necessarily the host that is
receiving the request due to virtual hosts and proxy servers.&nbsp;
This value comes from the <strong>Host:</strong> header line, if one
is given.&nbsp;</li>
</ul>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>A request contains other information and while that information
isn't used to determine
which entity will handle the request it can be used by the entity
handling the request in
any way it sees fit.</p>
<p>&nbsp;</p>
<p>The following functions create entities and specify which requests
they will handle.
&nbsp;&nbsp; An entity is distinguished by the <strong>path</strong>
and <strong>host</strong>
values passed to the particular <strong>publish</strong>
function.&nbsp;&nbsp; When a <strong>publish</strong>
is done for a <strong>path</strong> and <strong>host</strong> for
which there is already
an entity assigned, the old entity is replaced by the new entity.</p>
<p>&nbsp;</p>
<p><a name="f-publish-file"></a><strong><font face="Courier New">(publish-file
&amp;key
path
host
port&nbsp;
file
content-type
class
preload
cache-p
remove
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
authorizer
server
timeout
plist
hook
headers
compress)</font></strong></p>
<p>This creates an entity that will return the contents of a file on
the disk in response
to a request.&nbsp;&nbsp; The <strong>url</strong> and <strong>file</strong>&nbsp;
must
be
given,
the
rest
of
the
arguments
are
optional..&nbsp;
The arguments
have these meanings: </p>
<ul>
  <li><strong>path </strong>-- a string that must match the name part
of the url as described above in <strong>Components of a Request</strong></li>
  <li><strong>host -- </strong>normally <strong>nil</strong>.&nbsp;
If you wish to do virtual hosting read <a href="#virtual_hosts">this
section</a> describing how it's done.</li>
  <li><strong>port</strong> -- this argument is currently unused and
will likely be removed in future versions.</li>
  <li><strong>file </strong>-- the name of the file to return when a
request to this entity is made.&nbsp;&nbsp; The file doesn't have to
exist until the request is made unless <strong>preload</strong> is
specified as true.</li>
  <li><strong>content-type</strong> -- A string describing the content
of the file.&nbsp; This is often referred to as the MIME type of the
file.&nbsp; An example is "text/html" to describe an html file.&nbsp;
If a content-type value is not provided, then AllegroServe checks the
pathname-type in the&nbsp; *mime-types* hash table to see if there is a
content-type associated with this pathname-type.&nbsp; If it fails to
find a content-type then it uses the type
"application/octet-stream".&nbsp; </li>
  <li><strong>class</strong> -- a Clos class name or class object to be
used to hold this entity.&nbsp; The class must be a subclass of&nbsp; <strong>file-entity</strong>.
&nbsp;&nbsp;








  </li>
  <li><strong>preload</strong> --if true it instructs <strong>AllegroServe</strong>
to read the contents of the file in immediately and store it in a lisp
object.&nbsp; This will speed up the response to this request.&nbsp; If
the file on disk is updated AllegroServe will ignore the preloaded
content and will access the content from disk.&nbsp;&nbsp; If <strong>preload</strong>
is true then you most likely want to specify <strong>cache-p</strong>
true as well.</li>
  <li><strong>cache-p</strong> -- if true then <strong>AllegroServe</strong>
will cache the last value read for this file.&nbsp; When asked for this
file <strong>AllegroServe</strong> will check to see if the file has
changed on disk (using the last modified time as a measure).&nbsp; If
the file hasn't changed AllegroServe will return the cached value,
otherwise <strong>AllegroServe</strong> will read in and cache the new
contents of the file and will return that as a response.</li>
  <li><strong>remove </strong>-- instead of adding an entity, remove
the entities that match the given <strong>path</strong> and <strong>host.









    </strong>This removes all entities, not just file entities.&nbsp;
If a <strong>host</strong> value is not passed in an argument, then
this will remove all entities for this <strong>path</strong>,
regardless of their <strong>host</strong> values.</li>
  <li><strong>server</strong> -- if this entity should only be served
by a particular server, then this specifies which server.&nbsp;&nbsp;
See the section (to be written) on running multiple servers in the same
Lisp process.</li>
  <li><strong>timeout</strong> - specifies the number of seconds
AllegroServe has to return this file to the http client.&nbsp; If
AllegroServe is running in a lisp that supports timeouts on each I/O
operation (e.g. Acl 6.1 or newer) then the default value for this
argument is a huge number, meaning in effect that there will be no time
limit on the transfer.&nbsp;&nbsp; If I/O timeouts are not supported
then the default value of this argument is <strong>nil</strong>
meaning ignore this value and use the timeout value held in the server
object and retrieved with<strong> wserver-response-timeout</strong>..</li>
  <li><strong>plist</strong> - initial property list for this entity</li>
  <li><strong>hook</strong> - a function of three arguments: req,ent
and extra. &nbsp;&nbsp; See <a href="#entity-hook-function">entity
hook function</a>.</li>
  <li><span style="font-weight: bold;">headers</span>
- a list of cons's, with the car being a&nbsp; keyword symbol naming a
header and the cdr being a string which is the header value.&nbsp;
These headers are added to the response send back to the browser when
this file is accessed.&nbsp;&nbsp;</li>
  <li><span style="font-weight: bold;">compress</span> - If true then
this directs the server to look for a compressed version of the file if
the client will specifies that it will accepts a compressed
body.&nbsp;&nbsp;&nbsp; The compressed version must be in the same
directory as the uncompressed version.&nbsp; Currently we only look for
files compressed with gzip and we identify those files as ending with
".gz".&nbsp;&nbsp; See the <a href="#compression">Compression</a>
section.<br>
  </li>
</ul>
<p>The function that handles requests for files will respond correctly
to <strong>If-Modified-Since</strong>
header lines and thus minimizes network traffic. </p>
<p>Example: </p>
<p>This will work on Unix where the password file is stored in /etc.</p>
<pre>(publish-file :path "/password" :file "/etc/passwd" :content-type "text/plain")</pre>
<h3><a name="entity-hook-function"></a>Entity Hook Function</h3>
<p>AllegroServe supplies many subclasses of entity which automatically
generate a
responses to requests.&nbsp;&nbsp;&nbsp;&nbsp; There are times when
user code needs to run
during the generation of&nbsp; a response by one of the built-in entity
classes.
&nbsp;&nbsp; For example you may wish to add or modify the headers that
will be sent back
with the <strong>publish-file</strong>'s response.&nbsp;&nbsp;&nbsp;
The entity hook
function is called just before the<strong> with-http-body</strong> in
the response
function.&nbsp; At this point all the response headers have been
specified but the hook
function is free to change them or add new headers.</p>
<p>The entity hook function takes three arguments: <strong>req</strong>,
<strong>ent</strong>
and <strong>extra</strong>.&nbsp;&nbsp; <strong>Req</strong> and <strong>ent</strong>
are
the familiar http-request and entity arguments.&nbsp;&nbsp; <strong>Extra</strong>
is
usually <strong>nil</strong> but will be one of the following symbols
to tell&nbsp; the
hook function if it's being called in a special context.</p>
<table border="1" width="100%">
  <tbody>
    <tr>
      <td width="21%"><strong>:illegal-range</strong></td>
      <td width="79%">request has asked for a range of bytes that is
not present in the entity. &nbsp; As a result a "416 - Illegal Range
Specified"&nbsp; response is being generated.</td>
    </tr>
    <tr>
      <td width="21%"><strong>:in-range</strong></td>
      <td width="79%">request has asked for a range of bytes and that
range is being returned.</td>
    </tr>
    <tr>
      <td width="21%"><strong>:not-modified</strong></td>
      <td width="79%">request contains an "If Not Modified" header and
AllegroServe is returning a "304 - Not Modified" response.</td>
    </tr>
  </tbody>
</table>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p><a name="f-publish-directory"></a><strong><font face="Courier New">(publish-directory
&amp;key
prefix
host
port
destinations
remove
authorizer
server
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
indexes
filter
timeout
plist
publisher
access-file<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
hook
headers
compress
hidden-index-redirect)</font></strong></p>
<p><strong>publish-directory</strong> is used to publish a complete
directory tree of
files.&nbsp; This is similar to how web servers such as Apache publish
files. &nbsp;
AllegroServe publishes the files in&nbsp; the directory tree in a <em>lazy</em>
manner.&nbsp;&nbsp; As files in the tree are referenced by client
requests entities are
created and published.&nbsp; </p>
<p><strong>publish-directory</strong> creates a mapping from all urls
whose name begins
with<strong> prefix</strong> to files stored in the directories
specified
by the <strong>destination</strong><span style="font-weight: bold;">s</span>.&nbsp;&nbsp;&nbsp;
<span style="font-weight: bold;">destinations </span>may either be a
single directory or a list of directories to search. The <strong>host</strong>,
<strong>port, remove, authorizer, plist,
hook, headers </strong>and <strong>server</strong>
arguments are as described above for <strong>publish-file.</strong>
&nbsp;&nbsp;&nbsp;&nbsp; The <strong>timeout</strong> argument
defaults as described in <strong>publish-file</strong>.
&nbsp;The <strong>hook</strong> argument specifies what hook function
should be put in the
entities that <strong>publish-directory</strong> creates.&nbsp;&nbsp;
The <strong>access-file</strong>
argument names the <a href="#directory-access-files">access file</a>
name which will be
used in this directory tree. When a request comes in for which there
isn't an entity that
matches it exactly,&nbsp; AllegroServe checks to see if a prefix of the
request has been
registered.&nbsp; If so, and if the resulting entity is a <strong>directory-entity</strong>
as created by this function, then it strips the prefix off the given
request and appends
the remaining part of the request to the destination string.&nbsp; It
then publishes that
(normally using <strong>publish-file</strong> and computing the
content-type from the file
type). &nbsp;&nbsp; Next that <strong>file-entity </strong>is made to
handle the request
in the normal manner.</p>
<p>If a request comes that maps to a directory rather than a file then
AllegroServe takes special action.&nbsp; First AllegroServe ensures
that the request uri ends in a slash. &nbsp; If the request was <span
 style="text-decoration: underline;">http://foo.com/onedir/twodir</span>&nbsp;
then AllegroServe will return a redirect response so the client now
asks for <span style="text-decoration: underline;">http://foo.com/onedir/twodir/
</span>.&nbsp; Next AllegroServe tries
to locate an index file for that directory.&nbsp; The <strong>indexes</strong>
argument
specifies a list of index files to search for.&nbsp; By default the
list consists of two
filenames "index.html" and "index.htm".&nbsp; If an index file is found
then the value of&nbsp; the<span style="font-weight: bold;"><span
 style="font-weight: bold;"><span style="font-weight: bold;"> </span></span>hidden-index-redirect
</span>argument is consulted.&nbsp; If it is nil then AllegroServe
returns a redirect to the index file, e.g&nbsp; <span
 style="text-decoration: underline;">http://foo.com/onedir/twodir/index.html</span>.<br>
If <span style="font-weight: bold;">hidden-index-redirect</span> is
true then AllegroServe will return the contents of the index file from
the request, effectively doing the redirection to the index file
internally and invisibly to the client.<br>
</p>
<p>The value of the <strong>filter </strong>argument is a function of
four values: <strong>req</strong>
<strong>ent</strong>&nbsp; <strong>filename</strong> and <strong>info</strong>.&nbsp;
<strong>req</strong>
and <strong>ent</strong> are the request and entity objects that
describe the current
client request. &nbsp;&nbsp;&nbsp; <strong>filename</strong> is the
name of a known file
on the current machine which&nbsp; is being requested by the current
request.&nbsp; <strong>info</strong>
is the list of <a href="#directory-access-files">access information</a>
for this file.</p>
<p>If the filter returns <strong>nil</strong> then the normal
operation&nbsp; is done by
the directory-entity handler: the selected file is published and then
the request to
access it processed (and subsequent access using that url will just
return the file and
never go through the filter again).</p>
<p>If the filter chooses to handle the request for the file
itself&nbsp; it must generate
a response to the request and then return a non-nil value.&nbsp; To
avoid subsequent calls
to the filter for this file the filter may choose to publish a handler
for this url.
&nbsp; If the filter wants to forbid access to this file a handy way to
to call <font face="Courier New">(failed-request req)</font> and the
standard "404 Not found"
will be sent back to the client.</p>
<p>The <strong>publisher</strong> argument can be used to specify
exactly what happens
when a request comes that's handled by the <strong>directory-entity </strong>and
a
file
is
located
on
the
disk
that
matches
the
incoming <strong>url</strong>.&nbsp;&nbsp;
Nomally
a
<strong>publish-file</strong>
is done to add that file.&nbsp; You may want to publish some other kind
of entity to
represent that file.&nbsp; The <strong>publisher</strong> argument, if
non-nil, must be a
function of&nbsp; four arguments:&nbsp; <strong>req ent filename</strong>
<strong>info</strong>.&nbsp;
The filename is a string naming the file that's been matched with the
request.&nbsp;&nbsp;
<strong>info</strong> is the list of <a href="#directory-access-files">access
information</a>
for this file.&nbsp; The <strong>publisher</strong> function must
return an entity to be
processed to send back a response.&nbsp;&nbsp; The <strong>publisher</strong>
function may
wish to publish that entity but it need not do so.</p>
<div align="center">
<center>
<table border="1" cellpadding="5" width="86%">
  <tbody>
    <tr>
      <td width="100%">Note:&nbsp; <strong>publish-directory</strong>
is a more general function than its name implies.&nbsp;&nbsp;&nbsp; It
looks at each url path for a match for <strong>prefix </strong>and if
such a match is found the <strong>prefix</strong> is removed and
replaced with <strong>destination</strong>.&nbsp;&nbsp; Thus is prefix
is <strong>"/foo"</strong> and destination is <strong>"/bar"</strong>
then a url path of&nbsp; <strong>"/foobaz/joe.html" </strong>would be
converted to <strong>"/barbaz/joe.html".</strong> &nbsp;&nbsp;&nbsp;
This is rarely useful but it does show that you have to be careful
about the prefix and destination strings.&nbsp; It's usually the case
that if the prefix string ends in <strong>"/"</strong> then the
destination string should end in <strong>"/"</strong> (and vice
versa).&nbsp; Thus a prefix of <strong>"/foo"</strong> would have a
destination of <strong>"/bar" </strong>and a prefix of <strong>"/foo/"</strong>
would have a destination of <strong>"/bar/"</strong>.&nbsp; </td>
    </tr>
  </tbody>
</table>
</center>
</div>
<p>&nbsp;The <span style="font-weight: bold;">compress</span> argument
specifies the value to pass for the <span style="font-weight: bold;">:compress
</span>argument to <span style="font-weight: bold;">publish-file</span>
when an entity is located i the directories and a <span
 style="font-weight: bold;">publish-file</span> is done automatically.<br>
</p>
<h3><a name="directory-access-files"></a>Directory Access Files</h3>
<p>When files are accessed and automatically published you may wish to
set some of the
parameters of the entity that is published. As mentioned above you can
define a <strong>publisher</strong>
function that has complete control in publishing the entity.&nbsp; A
less powerful but
easier to use alternative is to place <em>access files </em>in the
directory tree being
published.&nbsp;&nbsp; An access file specifies information that you
want passed to the
publisher function.&nbsp; You can modify these access files while the
directory tree is
published and their latest values will be used for publishing <em>subsequent</em>
files.
&nbsp;&nbsp; This is similar to they way Apache controls its publishing
with <strong>.htaccess</strong>
files (except that in AllegroServe once a file is published the access
files have no
effect on it).</p>
<p>The name of an access file in AllegroServe is controlled by the <strong>:access-file</strong>
argument to <strong>publish-directory.</strong>&nbsp;&nbsp; We'll
assume the name chosen
is <strong>access.cl</strong> in this document.&nbsp;&nbsp; If no <strong>:access-file</strong>
argument is given to <strong>publish-directory</strong> then no access
file checking is
done. &nbsp;When a file is about to be published all access files from
the <strong>destination</strong>
directory all the way down to the directory containing the file to be
published are read
and used.&nbsp; For example if the <strong>destination</strong> in a <strong>publish-directory
</strong>was given as "/home/joe/html/" and an http request comes in
which
references the file "/home/joe/html/pics/archive/foo.jpg"&nbsp; then
AllegroServe will check for access files at <em>all</em> of these
locations and in this
order </p>
<ul>
  <li>/home/joe/html/access.cl</li>
  <li>/home/joe/html/pics/access.cl</li>
  <li>/home/joe/html/pics/archive/access.cl</li>
</ul>
<p>The information is collected as successive access files are
read.&nbsp; The new
information is placed before the existing information thus causing
subdirectory &nbsp;
access files to possibly shadow information in access files in
directories above it.&nbsp;
Also superdirectory access file information is automatically eliminated
if it isn't marked
as being <em>inherited<strong>.&nbsp; </strong></em></p>
<p>The <strong>publisher </strong>function receives the collected
information and can do
with it what it wishes.&nbsp; We'll describe what the built-in
publisher function does
with the information.</p>
<p>When we speak of <em>information<strong> </strong></em>in access
files we are purposely
being vague.&nbsp;&nbsp; We define what information must look like and
what the standard
publisher function does with certain information but we allow users to
define their own
kinds of information and use that in their own publisher function.</p>
<p>Each access file consists of zero or more Lisp forms (and possibly
lisp style
comments).&nbsp; Each form is&nbsp; a list beginning with a keyword
symbol and then
followed by a property-list-like sequence of &nbsp; keywords and
values.&nbsp;&nbsp;
Nothing in the form is evaluated. &nbsp;&nbsp;&nbsp; The form cannot
contain #. or #,.
macros.</p>
<p>One&nbsp; information form is used by AllegroServe's directory
publisher code to decide
if it's permitted to descend another directory level:</p>
<p><strong>(:subdirectories&nbsp; :allow </strong><em>allow-list</em><strong>
:deny </strong><em>deny-list</em><strong>
:inherit </strong><em>inherit-value</em><strong>)</strong></p>
<p>As AllegroServe descends from the <strong>destination</strong>
directory toward the
directory containing the file to be accessed it stops at each directory
level accumlates
the access information and then tests to see if it can descend further
based on the <strong>:subdirectories
</strong>information.&nbsp;&nbsp; If it cannot descend into the next
subdirectory it gives
up immediately and a <strong>404 - Not Found</strong> response is
returned. &nbsp;&nbsp;
See the section Allow Deny processing below for a description of how it
uses the <strong>:allow</strong>
and <strong>:deny</strong> values.</p>
<p>These other information forms are used by the standard publisher
function. &nbsp;&nbsp;
Each takes an <strong>:inherit</strong> argument which defaults to
false. &nbsp;
Information not given with&nbsp; <strong>:inherit t</strong> will be
eliminated as AllegroServe
descends directory levels.</p>
<table border="1" width="100%">
  <tbody>
    <tr>
      <th width="15%">name</th>
      <th width="17%">args</th>
      <th width="68%">meaning</th>
    </tr>
    <tr>
      <td width="15%"><strong>:ip</strong></td>
      <td width="17%"><strong>:patterns <br>
:inherit</strong></td>
      <td width="68%">specifies a<a href="#c-location-authorizer">
location-authorizer</a> restriction on which machines can see published
files.&nbsp; The value of the <strong>:patterns</strong> argument has
the same form as the <strong>:patterns</strong> slot of a
location-authorizer.</td>
    </tr>
    <tr>
      <td width="15%"><strong>:password</strong></td>
      <td width="17%"><strong>:realm<br>
:allowed<br>
:inherit</strong></td>
      <td width="68%">specifies a <a href="#c-password-authorizer">password-authorizer</a>
restriction on access to published files. &nbsp; See the
password-authorizer documentation for a description of the <strong>:realm</strong>
and <strong>:allowed</strong> arguments</td>
    </tr>
    <tr>
      <td width="15%"><strong>:files</strong></td>
      <td width="17%"><strong>:allow<br>
:deny<br>
:inherit</strong></td>
      <td width="68%">specifies which files are visible to be
published.&nbsp; To be visible a file must be allowed and not
denied.&nbsp; What is tested is the filename only (that is the part
after the last directory separator in the files's complete name).&nbsp;
See below for the rules on how allow and denied is used.</td>
    </tr>
    <tr>
      <td width="15%"><strong>:mime</strong></td>
      <td width="17%"><strong>:types<br>
:inherit</strong></td>
      <td width="68%">specifies which mime types are to be associated
with which file types. &nbsp; This list takes precedence over the
built-in list inside AllegroServe.&nbsp; :types is a list of mime
specifiers.&nbsp;&nbsp; A mime specifier is a list beginning with a
string giving the mime type followed by the files types that should map
to that mime type. &nbsp; A file type in a list (e.g. ("ReadMe"))
refers to the whole file name rather than the type component.</td>
    </tr>
  </tbody>
</table>
<h3>Allow and Deny Processing</h3>
<p>The <strong>:files </strong>and <strong>:subdirectories</strong>
information are used
to determine if a file or subdirectory of a given name is
accessible.&nbsp; AllegroServe
will collect all the access file information for the directory
containing the file or
subdirectory and for all directories above it up to the directory given
as the <strong>destination</strong>
argument to <strong>publish-directory.&nbsp; </strong>Information
from superdirectories
will only be used if <strong>:inherit t</strong> is given for that
information.&nbsp; </p>
<p>The rule is it that a given name is accessible if it is allowed and
not denied. &nbsp;
That is the filename or directory name must match one of the allow
clauses and none of the
deny clauses.&nbsp; There may be multiple allow and deny clauses since
there may be
multiple information forms of the type <strong>:files </strong>or <strong>:subdirectories</strong>.
&nbsp;&nbsp;
Each
allow
or
deny
argument
can
be
a
string or a list of
strings or nil
(which is the same as that argument not being given).<strong> </strong>&nbsp;
The
strings
are
regular
expressions
(which
are
not
exactly
like
unix shell wildcard
filename
expressions).&nbsp;&nbsp; In particular <font face="Courier New">".*"</font>
is
the regular expression that matches anything.</p>
<p>The special cases are the following </p>
<ul>
  <li>if <strong>:allow</strong> is given as nil or is not given at
all then that is the same as specifying <font face="Courier New">".*"</font>
the regular expression that matches everything.</li>
  <li>if <strong>:deny</strong> is given as nil or is not given then
that is the same as specifying a regular expression that matches
nothing.</li>
  <li>if AllegroServe is looking for <strong>:files </strong>information
and
there
is
none
to
be
found
in
the
accumulated information, then
access is allowed.&nbsp;&nbsp; A similar thing is true if AllegroServe
is searching for <strong>:subdirectories</strong> information and none
is found.</li>
</ul>
<p>&nbsp;</p>
<p>.</p>
<p>Here is a sample access file:</p>
<p><font face="Courier New">; only connections to localhost will be
able to access the
files<br>
(:ip :patterns ((:accept "127.1") :deny) :inherit t)&nbsp;&nbsp;&nbsp; <br>
(:password :realm "mysite" <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :allowed
(("joe" .
"mypassword")<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
("sam"
.
"secret"))
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :inherit
t) ;&nbsp; applies
to subdirectories<br>
; publish html and cgi files, but not those beginning with a period<br>
(:files :allow ("\\.html$" "\\.cgi$") :deny ("^\\.")) <br>
; specify mime type for non-standard file extensions.&nbsp; Also<br>
; specify that a file named exactly ChangeLog should be given<br>
; mime type "text/plain"<br>
(:mime :types (("text/jil" "jil" "jlc")
("text/plain" "cl" ("ChangeLog"))))</font></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p><a name="f-publish"></a><strong><font face="Courier New">(publish
&amp;key path host
port content-type function class format remove server <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
authorizer
timeout
plist
hook
headers)</font></strong></p>
<p>This creates a mapping from a url to a <strong>computed-entity</strong>,
that
is
an
entity
that
computes
its
response
every
time
a request comes in.&nbsp;
The <strong>path</strong>,
<strong>host</strong>, <strong>port</strong>, <strong>remove, server</strong>
, <strong>authorizer,
hook, headers </strong>and <strong>class</strong> arguments are as in
the
other publish
functions.&nbsp;&nbsp;The <strong>timeout</strong> argument defaults
to <strong>nil </strong>always.&nbsp;&nbsp;
The <strong>content-type</strong> sets a default value for the
response to the request but
this can be overridden.&nbsp; The <strong>format</strong> argument is
either <strong>:text
</strong>(the default) or <strong>:binary</strong> and it specifies
the kind of value that
will be sent back (after the response headers, which are always in
text).&nbsp;&nbsp; This
value is only important if the response is generated in a particular
way (described
below).&nbsp;&nbsp; The value of the<strong> hook</strong> argument is
stored in the
entity created however the hook function will only be run if the <strong>function</strong>
supplied makes use of it.</p>
<p>The <strong>function </strong>argument is&nbsp; a function of two
arguments: an object
of class <strong>http-request</strong> that holds a description of the
request, and an
object of class <strong>entity </strong>that holds this entity which
is handling the
request.&nbsp;&nbsp; This function must generate a response to the http
request, even if
the response is only that the request wasn't found.</p>
<p>&nbsp;</p>
<p><a name="f-publish-prefix"></a><strong><font face="Courier New">(publish-prefix
&amp;key
prefix
host
port
content-type
function
class <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
format
remove
server
authorizer
timeout
plist
hook
headers)</font></strong></p>
<p>This is like <strong>publish </strong>except that it declares <strong>function</strong>
to be the handler for all urls that begin with the string <strong>prefix</strong>.
&nbsp;&nbsp;
Note
however
that
prefix
handlers
have
lower
priority
than
exact handlers.
&nbsp; Thus if you declare a prefix handler for "/foo" and also a
specific
handler for "/foo/bar.html" then the specific handler will be chosen if
"/foo/bar.html" is found in an http request.&nbsp;&nbsp; Typically a
prefix
handler is used to make available a whole directory of files since
their complete names
begin with a common prefix (namely the directory in which the files are
located).
&nbsp;&nbsp; If you want to publish a whole directory then you probably
want to use <strong>publish-directory</strong>
since it has a number of features to support file
publishing.&nbsp;&nbsp; The value of the<strong>
hook</strong> argument is stored in the entity created however the hook
function will only
be run if the <strong>function</strong> supplied makes use of it.</p>
<p>&nbsp;</p>
<p><a name="f-publish-multi"></a><strong><font face="Courier New">(publish-multi
&amp;key
path
host
port
content-type
items
class
remove
server
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
authorizer
timeout
hook
headers)</font></strong></p>
<p>Some web pages are created from information from various
sources.&nbsp;&nbsp; <strong>publish-multi</strong>
allows you to specify a sequence of places that supply data for the
combined web page.
&nbsp; The data for each page is cached by <strong>publish-multi</strong>
so that minimal
computation is required each time the page is
requested.&nbsp;&nbsp;&nbsp; </p>
<p>The <strong>host, port, content-type, class, remove, server,
authorizer, hook, headers </strong>and<strong>
timeout</strong> arguments are the same as those of the other publish
functions.
&nbsp;&nbsp; The <strong>items </strong>argument is unique to <strong>publish-multi</strong>
and is a list of zero or more of the following objects </p>
<ul>
  <li>string or pathname - this is a reference to a file on the
server.&nbsp; This item contributes the contents of the file to the
final web page.</li>
  <li>symbol or function - this is a function of four arguments: <strong>req
ent
cached-time
cached-value</strong>.&nbsp;&nbsp; It returns two
values:&nbsp; the new value and the last modified time of the
value.&nbsp;&nbsp; The function may look at the cached-value or
cached-time and realize that nothing has changed since that time that
would cause this function to return a new value.&nbsp; In that case it
should return the cached-value and cached-time that it received as
arguments.&nbsp;&nbsp; If a value must always be computed each time the
function is called it may return <strong>nil</strong> for the last
modified time.&nbsp; This will result in no LastModified header being
sent in the response. &nbsp;&nbsp; The value the function returns can
either be a string or an array of unsigned-byte 8 values.&nbsp;&nbsp;
It's preferred to return an array of unsigned-byte 8 values.&nbsp; If a
string is returned then<strong> </strong>it will be converted to an
array of unsigned-byte 8 by using <strong>(string-to-octets string
:null-terminate nil). &nbsp;&nbsp; </strong>The cached-value argument
to the function will be <strong>nil</strong> or an unsigned-byte 8
array.</li>
  <li><strong>(:string</strong> string<strong>) - </strong>this item
supplies the given string to the web page.</li>
  <li>(<strong>:binary</strong> vector) - vector should be a one
dimensional simple-array of (unsigned-byte 8).&nbsp; This vector of
bytes is added to the web page.</li>
</ul>
<p>Here's an example where we create a page from a fixed header and
trailer page with a
bit of dynamic content in the middle.</p>
<pre>(publish-multi :path "/thetime"<br>	       :items (list "header.html"<br>			    #'(lambda (req ent old-time old-val)<br>				(declare (ignore req ent old-time old-val))<br>				(with-output-to-string (p)<br>				  (html-stream p<br>					       :br<br>					       "The time is "<br>					       (:princ (get-universal-time))<br>					       (:b<br>						"Lisp Universal Time")<br>					       :br)))<br>			    "footer.html"))<br>				   </pre>
<h2><a name="generating-a-computed-response"></a>Generating a computed
response </h2>
<p>There are a variety of ways that a response can be sent back to the
http client
depending on whether keep-alive is being done, chunking is possible,
whether the response
is text or binary, whether the client already has the most recent data,
and whether the
size of the body of the response is known before the headers are
sent.&nbsp; AllegroServe
handles the complexity of determining the optimal response strategy and
the user need only
use a few specific macros in the computation of the response in order
to take advantage of
AllegroServe's strategy computation</p>
<p>Here's a very simple computed response.&nbsp; It just puts "Hello
World!" in
the browser window:</p>
<pre>(publish :path "/hello"<br>         :content-type "text/html"<br>         :function #'(lambda (req ent)<br>                       (with-http-response (req ent)<br>                          (with-http-body (req ent)<br>                             (html "Hello World!")))))<br><br><br><br></pre>
<p align="left">This example works regardless of whether the request
comes in from an old
HTTP/0.9 browser or a modern HTTP/1.1 browser.&nbsp; It may or may not
send the response
back with chunked transfer encoding and it may or may not keep the
connection alive after
sending back the response.&nbsp;&nbsp; The user code doesn't have to
deal with those
possibilities, it just uses <strong>with-http-response</strong> and <strong>with-http-body</strong>
and the rest is automatic.&nbsp; The <strong>html</strong> macro is
part of the htmlgen
package that accompanies AllegroServe.&nbsp;&nbsp; In the case above we
are being lazy and
not putting out the html directives that should be found on every page
of html since most
browsers are accommodating.&nbsp;&nbsp; Here's the function that
generates the correct
html:</p>
<div align="left">
<pre>(publish :path "/hello2"<br>         :content-type "text/html"<br>         :function #'(lambda (req ent)<br>                       (with-http-response (req ent)<br>                         (with-http-body (req ent)<br>                          (html <br>                             (:html<br>                               (:body "Hello World!")))))))</pre>
</div>
<p align="left">&nbsp;</p>
<p align="left">The function above generates: <font face="Courier New">&lt;html&gt;&lt;body&gt;Hello
World!&lt;/body&gt;&lt;/html&gt;.</font></p>
<p align="left">&nbsp;</p>
<p align="left">The macros and functions used in computing responses
are these:</p>
<hr>
<p align="left"><a name="f-with-http-response"></a><strong><font
 face="Courier New">(with-http-response
(req ent &amp;key timeout check-modified format response content-type) <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&amp;rest
body)</font></strong></p>
<p align="left">This macro begins the process of generating a response
to an http request
and then&nbsp; runs the code in the <strong>body</strong> which will
actually send out the
response.&nbsp; <strong>req</strong> and <strong>ent</strong> are the
request and entity
objects passed into the function designated to compute the response for
the request.
&nbsp;&nbsp;&nbsp; <strong>timeout </strong>sets a time limit for the
computation of the
response.&nbsp;&nbsp; If <strong>timeout</strong> is nil then the
entity <strong>ent</strong>
is checked for a timeout value.&nbsp; If that value is also nil then
the timeout value is
retrieved from the current <strong>wserver</strong> object using <strong>wserver-response-timeout</strong>.
&nbsp;
If
<strong>check-modified </strong>is true (the default) then
the <strong>last-modified
</strong>time stored in the entity object will be compared against the <strong>if-modified-since
</strong>time of the request and if that indicates that the client
already has the latest
copy of this entity then a <strong>not-modified</strong> response will
be automatically
returned to the client and the <strong>body </strong>of this macro
will not be
run.&nbsp;&nbsp; <strong>response </strong>is an object containing
the code and
description of the http response we wish to return. &nbsp;&nbsp; The
default value is the
value of <strong>*response-ok*</strong> (which has a code of 200 and a
string descriptor
"OK").&nbsp;&nbsp; <strong>content-type </strong>is a string
describing the MIME
type of the body (if any) sent after the headers.&nbsp; It has a form
like
"text/html".&nbsp;&nbsp; If <strong>content-type</strong> isn't given
here then
the content-type value in the entity (which is set in the call to <strong>publish)</strong>
will be used.</p>
<p align="left">The <strong>format</strong> argument specifies whether
the code that
writes the body of the response will want to write <strong>:text</strong>
(e.g. <strong>write-char</strong>)
or <strong>:binary</strong> (e.g. <strong>write-byte</strong>) when
it writes the data of
the body of the response. &nbsp;&nbsp;&nbsp;&nbsp; Based on the value
of the <strong>format</strong>
argument, AllegroServe will create the correct kind of response
stream.&nbsp;&nbsp; If <strong>format
</strong>is not specified here it will default to the value specified
when <strong>publish</strong>
was called to create the entity.&nbsp; If not <strong>:format </strong>argument
was
passed
to
<strong>publish</strong> then <strong>:binary</strong> format is
assumed.
&nbsp;&nbsp;&nbsp; If <strong>:binary</strong> is specified then you
can write both text
and binary to the stream&nbsp; since Allegro's binary streams also
support text calls as
well.&nbsp; If you specify <strong>:text</strong> then you may end up
with a stream that
supports only text operations.</p>
<p align="left">An http response consists of a line describing the
response code, followed
by headers (unless it's the HTTP/0.9 protocol in which case there are
no headers),
&nbsp;&nbsp; and then followed by the body (if any) of the
response.&nbsp;&nbsp; <strong>with-http-response</strong>
doesn't normally send anything to the client.&nbsp; It only does so
when it determines
that the <strong>if-modified-since</strong> predicate doesn't hold and
that it must send
back a <strong>not-modified</strong> response.&nbsp;&nbsp;&nbsp;
Thus&nbsp; is not enough
to just call <strong>with-http-response</strong> in your response
function.&nbsp; You must
always call <strong>with-http-body </strong>inside the call to <strong>with-http-response</strong>.</p>
<p align="left">&nbsp;</p>
<hr>
<p align="left"><a name="f-with-http-body"></a><strong><font
 face="Courier New">(with-http-body
(req ent &amp;key format headers external-format)&nbsp; &amp;rest body)</font></strong></p>
<p align="left">This macro causes the whole http response to be sent
out.&nbsp; The macro
itself will send out everything except the body of the response.&nbsp;
That is the
responsibility of the code supplied as the <strong>body </strong>form
of the macro.
&nbsp;&nbsp;&nbsp; In cases where there is no body to the response
being sent it is still
necessary to call <strong>with-http-body </strong>so that the other
parts of the response
are sent out, e.g.<font face="Courier New"> </font>at a minimum you
should put<font face="Courier New"> (with-http-body (req ent)) </font>in
the
body
of
a
with-http-response.</p>
<p align="left"><em>The <strong>body </strong>forms may not be
executed! </em>If the
request is an http <strong>head</strong> request then the browser
wants only the headers
returned.&nbsp;&nbsp; The <strong>with-http-body </strong>macro will
not evaulate the <strong>body</strong>
forms.&nbsp;&nbsp; You must be aware of this and should never put code
in the <strong>body
</strong>form that absolutely must be executed when a request is given.</p>
<p align="left">The <strong>headers</strong> argument is a list of
conses, where the car
is the header name (a keyword symbol) and the cdr is the header
value.&nbsp; These headers
are added to the headers sent as part of this response.</p>
<p align="left">Within the <strong>body </strong>forms the code calls
<strong>(request-reply-stream
req)</strong> to obtain a stream to which it can write to supply the
body of the response.
&nbsp; The external-format of this stream is set to the value of the <strong>external-format</strong>
argument (which defaults to the value of <strong>*default-aserve-external-format*</strong>).&nbsp;&nbsp;
The
variable
<strong>*html-stream*</strong> is bound to the value of <strong>(request-reply-stream
req)</strong> before the <strong>body</strong> is
evaluated.&nbsp;&nbsp; This makes it
easy&nbsp; to use the <strong>html</strong> macro to generate html as
part of the
response. </p>
<p align="left"><em>Note: there used to be a <strong>:format</strong>
argument to <strong>with-http-body.
</strong>That argument was never used by <strong>with-http-body</strong>.&nbsp;
The
<strong>:format
</strong>argument has been moved to <strong>with-http-response </strong>so
that
it
can
now
have
an
effect
on
the
stream
created.</em></p>
<hr>
<p><a name="f-get-request-body"></a><strong><font face="Courier New">(get-request-body
request
&amp;key
external-format)</font></strong></p>
<p>Return the body of the request as a string.&nbsp; If there is no
body the return value
will be an empty string.&nbsp;&nbsp; The result is cached inside the
request object, so
this function can be called more than once while processing a
request.&nbsp;&nbsp; The
typical reason for there to be a body to a request is when a web
browser sends the result
of a form with&nbsp; a POST method.&nbsp;&nbsp; The octets that make up
the body of the
request are converted to a string (and then cached) using the <strong>:octets</strong>
external format as this is the appropriate external format if the
request body contains a
list of form values.</p>
<p>If an <strong>external-format</strong> is specified the body is
reconverted to a string
using the given external-format and then returned from this
function.&nbsp;&nbsp; This
reconversion does not affect the cached value.</p>
<hr>
<p><a name="f-header-slot-value"></a><strong><font face="Courier New">(header-slot-value
request
header-name)</font></strong></p>
<p>Return the value given in the request for the given header-name (a
keyword symbol).
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;If the header wasn't present in this
request then nil will
be returned.&nbsp;&nbsp; <strong>header-slot-value</strong> is a macro
that will expand
into a fast accessor if the <strong>header-name</strong> is a constant
naming a known
header slot</p>
<p>I<em>n older versions of aserve the<strong> header-name</strong> was
a string..</em></p>
<p>&nbsp;</p>
<hr>
<p><a name="f-reply-header-slot-value"></a><font face="Courier New"><strong>(reply-header-slot-value
request
header-name)</strong></font></p>
<p>Return the value associated with the header <strong>header-name</strong>
in the reply
sent back to the client.&nbsp; This function is setf'able and this is
the preferred way to
specify headers and values to be sent with a reply.</p>
<hr>
<p><a name="f-request-query"></a><strong><font face="Courier New">(request-query
request
&amp;key
uri
post
external-format)</font></strong></p>
<p>Decode and return an alist of the query values in the
request.&nbsp;&nbsp; Each item in
the alist is a cons where the car is a string giving the name of the
argument and the cdr
is a string giving the value of the argument.</p>
<p>The query string is in one or both of two places: </p>
<ul>
  <li>it begins at the first question mark in the uri and continues
until the end of the uri or a sharp sign (#), whichever comes first.</li>
  <li>it is in the body of a POST request from a web client.</li>
</ul>
<p><strong>request-query</strong> will by default look in both
locations for the query
string and concatenate the results of decoding both query
strings.&nbsp; If you would like
it to not check one or both of the locations you can use the <strong>:uri</strong>
and <strong>:post</strong>
keyword arguments.&nbsp;&nbsp; If <strong>uri</strong> is true (and
true is the default
value) then the query string in the uri is checked.&nbsp; If <strong>post</strong>
is true
(and true is the default value) and if the request is a POST then the
body of the post
form will be decoded for query values.</p>
<p>The <strong>external-format</strong> is used in the conversion of
bytes in the form to
characters.&nbsp; It defaults to the value of <strong>*default-aserve-external-format*</strong>.</p>
<p>A query is normally a set of names and values.&nbsp; <br>
<strong>http://foo.com/bar?a=3&amp;b=4 </strong>yields a query alist <strong>(("a"
.
"3")
("b"
.
"4")).
</strong><br>
If a name doesn't have an associated value then the value in the alist
is the empty
string.&nbsp;<br>
<strong>http://foo.com/bar?a&amp;b=&amp;c=4</strong> &nbsp; yields a
query alist <strong>(("a"
. "") ("b" . "") (c . "4"))</strong></p>
<p>.&nbsp;&nbsp; </p>
<p><a name="f-request-query-value"></a><font face="Courier New"><strong>(request-query-value
key
request
&amp;key
uri
post
external-format
test)</strong></font></p>
<p>This combines a call to <strong>request-query</strong> to retrieve
the alist of query
keys and values, with a call to <strong>assoc</strong> to search for
the specific key, and
finally with a call to <strong>cdr</strong> to return just the value
from the assoc list
entry.&nbsp; The <strong>test</strong> argument is the function to be
used to test the
given key against the keys in the assoc list. It defaults to <strong>#'equal</strong>.
</p>
<p>If the given key is <em>not</em> present in the query <strong>nil</strong>
is returned.
&nbsp; If the given key <em>is</em> present in the query but doesn't
have an associated
value then the empty string is returned.</p>
<hr>
<h2><a name="request-variables"></a>Request Variables</h2>
<p>Every request has zero or or more <span style="font-style: italic;">request
variables</span>.&nbsp;&nbsp; A request variable is named by a lisp
string.&nbsp; The value of a request variable can be any<br>
lisp object.&nbsp; <br>
<br>
&nbsp;Initially a request has zero request variables.<br>
</p>
<p
 style="font-family: courier new,courier,monospace; font-weight: bold;"><a
 name="f-request-variable-value"></a>(request-variable-value req "name")</p>
<p>Return the value of the request variable named "name".&nbsp; Return
nil if there is no such request variable.</p>
<p>You&nbsp; can use&nbsp; <span
 style="font-family: courier new,courier,monospace;">(setf
(request-variable req "name") value)</span> to set the value of a
request variable.<br>
<br>
&nbsp;</p>
<h2><a name="request-object-readers"></a>Request Object Reader and
Accessors</h2>
<p>The request object contains information about the http request being
processed and it
contains information about the response that is being computed and
returned to the
requestor.&nbsp;&nbsp; The following functions access slots of the
request object. &nbsp;
Those with names beginning with <strong>request-reply-</strong> are
accessing the slots
which hold information about the response to the request.&nbsp;&nbsp;
When a function is
listed as an<em> accessor<strong> </strong></em>that means that it can
be <strong>setf</strong>'ed
as well as used to read the slot value.</p>
<p>&nbsp;</p>
<p><a name="f-request-method"></a><font face="Courier New"><strong>(request-method
request)</strong></font> - reader - a keyword symbol naming the kind of
request, typically
:get, :put or :post.</p>
<p><a name="f-request-uri"></a><strong><font face="Courier New">(request-uri
request)</font></strong>
- reader - a uri object describing the request.&nbsp;&nbsp; If the
request contains a
"Host:" header line then the value of this header is placed in the
uri-host and
uri-port slots of this uri object.</p>
<p><a name="f-request-protocol"></a><strong><font face="Courier New">(request-protocol
request)</font></strong> - reader - a keyword symbol naming the http
protocol
requested.&nbsp; It is either :http/0.9, :http/1.0 or :http/1.1.</p>
<p><a name="f-request-protocol-string"></a><font face="Courier New"><strong>(request-protocol-string
request)
</strong></font>- reader - a string naming the http protocol
requested. It is
either "HTTP/0.9", "HTTP/1.0" or "HTTP/1.1".</p>
<p><a name="f-request-socket"></a><strong><font face="Courier New">(request-socket
request)</font></strong> - reader - the socket object through which the
request was made
and to which the response must be sent.&nbsp;&nbsp;&nbsp; This object
can be used to
determine the IP address of the requestor.</p>
<p><a name="f-request-wserver"></a><strong><font face="Courier New">(request-wserver
request)</font></strong> - reader - the wserver object describing the
web server taking
this request</p>
<p><a name="f-request-raw-request"></a><strong><font face="Courier New">(request-raw-request
request)</font></strong> - reader -&nbsp; a string holding the exact
request made by the
client</p>
<p>&nbsp;</p>
<p><a name="f-request-reply-code"></a><strong><font face="Courier New">(request-reply-code
request)</font></strong> &nbsp;&nbsp;&nbsp;&nbsp; - accessor - the
value describes the
response code and string we will return for this request.&nbsp;&nbsp;
See the value of the
argument <strong>response</strong> in <strong>with-http-response</strong>
for more
information.</p>
<p><a name="f-request-reply-date"></a><strong><font face="Courier New">(request-reply-date
request)</font></strong> &nbsp;&nbsp;&nbsp;&nbsp; - accessor - the date
the response will
be made (in Lisp's universal time format).&nbsp; This defaults to the
time when the
request arrived.</p>
<p><a name="f-request-reply-headers"></a><strong><font
 face="Courier New">(request-reply-headers
request)</font></strong> - accessor - an alist of some of the headers
to send out with the
reply (other headers values are stored in specific slots of the request
object).&nbsp;
Each entry in the alist is a cons where the <strong>car</strong> is a
keyword symbol
holding the header name and the <strong>cdr</strong> is the value (it
is printed using the
<strong>~a</strong> format directive). &nbsp;&nbsp; Typically <strong>request-reply-headers</strong>
isn't used, instead the headers to be sent are passed as the <strong>:header</strong>
argument to <strong>with-http-body</strong>, or <strong>(setf
reply-header-slot-value)</strong>
is called.</p>
<p><a name="f-request-reply-content-length"></a><strong><font
 face="Courier New">(request-reply-content-length
request) </font></strong>&nbsp;&nbsp;&nbsp; - accessor -&nbsp; the
value to send as the
Content-Length of this response.&nbsp;&nbsp; This is computed
automatically by
AllegroServe and thus a user program shouldn't have to set this slot
under normal
circumstances.</p>
<p><a name="f-request-reply-plist"></a><strong><font face="Courier New">(request-reply-plist
request)</font></strong> &nbsp;&nbsp;&nbsp;&nbsp; - accessor -&nbsp;
this slot holds a
property list on which AllegroServe uses to store&nbsp; less important
information.&nbsp;
The user program can use it as well.</p>
<p><a name="f-request-reply-strategy"></a><font face="Courier New"><strong>(request-reply-strategy
request)</strong></font>&nbsp;&nbsp; - accessor - the strategy is a
list of symbols which
describe how AllegroServe will build a response stream and will send
back a
response.&nbsp; More details will be given about the possible
strategies at a future time.</p>
<p><a name="f-request-reply-stream"></a><strong><font face="Courier New">(request-reply-stream
request)</font></strong> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - accessor
-&nbsp; This is the
stream to be used in user code to send back the body of the
response.&nbsp;&nbsp;&nbsp;
This stream must&nbsp; be used instead of the value of <strong>request-socket</strong>.</p>
<p>&nbsp;</p>
<hr>
<h2><a name="cgi-program"></a>CGI Program Execution</h2>
<p>The <a href="http://hoohoo.ncsa.uiuc.edu/cgi/interface.html">Common
Gateway Interface</a>
(CGI) specification allows web servers to run programs in response to
http requests and to
send the results of&nbsp; the execution of those programs back the web
client.
&nbsp;&nbsp; The CGI programs finds information about the request in
its environment
variables and, in the case of a <strong>put</strong> or <strong>post</strong>
request, the
body of the request is sent to standard input of the program.</p>
<p>CGI is a clumsy and slow protocol for extending the behavior of a
web server and is
falling out of favor.&nbsp; However there are legacy CGI applications
you may need to call
from AllegroServe.&nbsp;&nbsp; You invoke an external program using the
CGI protocol with
the <strong>run-cgi-program</strong> function.</p>
<p><a name="f-run-cgi-program"></a><font face="Courier New"><strong>(run-cgi-program
req
ent
program
&amp;key
path-info
path-translated<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
script-name
query-string
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
auth-type
timeout
error-output
env
terminate)</strong></font></p>
<p>In response to an http request, this runs <strong>program</strong>
which must be a
string naming an exectuable program or script followed optionally by
command line
arguments to pass to that program.&nbsp; Before the <strong>program </strong>is
run
the
environment
variables
are
set
according
to
the
CGI
protocol.&nbsp; The
<strong>timeout</strong>
argument is how long AllegroServe should wait for a response from the <strong>program
</strong>before
giving up.&nbsp;&nbsp; The default is 200 seconds.&nbsp;&nbsp; The <strong>error-output
</strong>argument
specifies what should be done with data the cgi program sends to its
standard error.
&nbsp; This is described in detail below.&nbsp; The other keyword
arguments allow the
caller to specify values for the CGI environment variables that can't
be computed
automatically.&nbsp; <strong>path-info</strong> specifies the
PATH_INFO environment
variable, and similarly for<strong> path-translated, script-name,
query-string</strong>
and <strong>auth-type.</strong>&nbsp;&nbsp; If <strong>query-string</strong>
is <em>not</em>
given and the <strong>uri</strong> that invoked this request contains
a query part then
that query part is passed in the QUERY_STRING environment
variable.&nbsp;&nbsp; If <strong>script-name</strong>
is not given then its value defaults to the path of the uri of the
request.&nbsp;&nbsp; If
you wish to add or modify the environment variables set for the cgi
process you can
specify a value for <strong>env.&nbsp; </strong>The value of <strong>env</strong>
should
be a list of conses, the car of each cons containing the environment
variable name (a
string) and the cdr of each cons containing the environment variable
value (a
string).&nbsp;&nbsp; <strong>env</strong> is checked after all the
standard environment
variables are computed and the value given in <strong>env</strong>
will override the value
computed automatically.&nbsp; On Unix if <span
 style="font-weight: bold;">terminate</span> is true then after the cgi
program finishes responding (or the timeout period expires) the cgi
program will be forceably killed (first with SIGTERM and then SIGKILL)
if remains alive.<br>
</p>
<p>cgi programs send their result to standard output (file descriptor 1
on Unix).&nbsp; If
they encounter problems they often send informative messages to
standard error (file
descriptor 2 on Unix).&nbsp;&nbsp;&nbsp; The <strong>error-output</strong>
argument to
run-cgi-program allows the caller to specify what happens to data sent
to standard error.
&nbsp; The possibile values for <strong>error-output</strong> are:</p>
<table border="1" width="100%">
  <tbody>
    <tr>
      <td width="32%"><strong>nil</strong></td>
      <td width="68%">The cgi program's standard error is made the same
as the Lisp process' standard error.&nbsp;&nbsp; This standard error
may not be the same as the current binding of *standard-error*.</td>
    </tr>
    <tr>
      <td width="32%">pathname or string</td>
      <td width="68%">A file with the given name is opened and standard
error is directed to that file.</td>
    </tr>
    <tr>
      <td width="32%"><strong>:output</strong></td>
      <td width="68%">Standard error is directed to the same place as
standard output thus the error messages will be mixed into the result
of running the cgi program.</td>
    </tr>
    <tr>
      <td width="32%">symbol or function</td>
      <td width="68%">The function is run whenever there is data
available to be read from standard error.&nbsp; It must read that
data.&nbsp; It must return a true value if it detected an end of file
during the read and <strong>nil</strong> otherwise. &nbsp;&nbsp; The
function takes arguments: req ent stream</td>
    </tr>
  </tbody>
</table>
<p>A typical way of publishing a CGI page is this:</p>
<pre>(publish :path "/cgi/myprog"<br>         :function #'(lambda (req ent) <br>                        (run-cgi-program req ent "/server/cgi-bin/myprog")))</pre>
<p>If you're concerned about capturing the error output then here's an
example where we
supply&nbsp; a function to collect all the error output into a string.
Once collected we
simply print it out here but in a real web server you would want to
store it in a log
file.</p>
<pre>(defun cgierr (req ent)<br>  (let ((error-buffer (make-array 10<br>                                  :element-type 'character<br>                                  :adjustable t<br>                                  :fill-pointer 0)))<br>    (net.aserve:run-cgi-program<br>     req ent<br>     "aserve/examples/cgitest.sh 4"<br>     :error-output<br>     #'(lambda (req ent stream)<br>         (declare (ignore req ent))<br>         (let (eof)<br>           (loop<br>             (let ((ch (read-char-no-hang stream nil :eof)))<br><br>               (if* (null ch) then (return))<br><br>               (if* (eq :eof ch)<br>                  then (setq eof t)<br>                       (return))<br><br>               (vector-push-extend ch error-buffer)))<br>           eof<br>           )))<br><br>    (format t "error buffer is ~s~%" error-buffer)<br>    ))</pre>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p><strong>Note: </strong>The ability to run CGI programs from
AllegroServe was due to
features added in Allegro Common Lisp version 6.1.&nbsp;&nbsp; This
will not work in
earlier versions of Allegro CL.</p>
<hr>
<h2><a name="form-processing"></a>Form Processing</h2>
<p>Forms are used on web pages in order to allow the user to send
information to the web
server.&nbsp;&nbsp; A form consists of a number of objects, such as
text fields, file
fields, check boxes and radio buttons.&nbsp;&nbsp; Each field has a
name.&nbsp;&nbsp; When
the user takes a certain action, the form data is encoded and sent to
the web server.
&nbsp;&nbsp;&nbsp; There are three ways that data can be sent to the
web server.&nbsp; The
method used is determined by the attributes of the <strong>&lt;form&gt;</strong>
tag that
defines the form </p>
<ul>
  <li><strong>&lt;form method="get"&gt; -&nbsp; </strong>The data is
made part of the <strong>url</strong> that is sent to the web server
and is separated from the url itself by a question mark.&nbsp; The
AllegroServe url handler code uses <strong>(request-query</strong> <strong>req)</strong>
to retrieve the alist of form names and values.&nbsp;&nbsp; This method
has a few disadvantages - the amount of data that can be sent is
limited since the size of urls is limited.&nbsp; Also the data is
visible to everyone seeing the url and that may not be desirable.&nbsp;
  </li>
  <li><strong>&lt;form method="post"&gt; - </strong>The data is sent
in the body of the request.&nbsp;&nbsp;&nbsp; The&nbsp; AllegroServe
url handler should call <strong>(request-query</strong> <strong>req)</strong>
to retrieve and decode the data posted.&nbsp;&nbsp;&nbsp; In this
case&nbsp; <strong>request-query</strong> calls <strong>(get-request-body
req)</strong> to retrieve the body from the web browser and then <strong>(form-urlencoded-to-query
body)








    </strong>to turn it into an alist that associates form field
names with values.</li>
  <li><strong>&lt;form method="post" enctype="multipart/form-data"&gt;
- </strong>The data is sent in the body of the request in MIME format,
with each field in its own separate MIME entity.&nbsp;&nbsp;&nbsp; This
method is only necessary when one of the fields in the form is a <strong>&lt;input
type="file"&gt;</strong> since that causes the whole contents of a file
to be sent from the browser to the web server. &nbsp; When sending a
file you would like to include information such as the filename and
content-type of the file, and by sending it in MIME format there is
room for this information in the MIME header.&nbsp;&nbsp; We describe
how to retrieve data from such a form next.</li>
</ul>
<h3>Retrieving multipart/form-data information</h3>
<p>If you create a form with <strong>&lt;form method="post"
enctype="multipart/form-data"&gt;</strong> then your url handler must
do the
following to retrieve the value of each field in the form: </p>
<ol>
  <li>Call <strong>(get-multipart-header req)</strong> to return the
MIME headers of the next field.&nbsp; If this returns nil then there
are no more fields to retrieve.&nbsp; You'll likely want to call <strong>parse-multipart-header</strong>
on the result of <strong>get-multipart-header</strong> in order to
extract the important information from the header.</li>
  <li>Create a buffer and call <strong>(get-multipart-sequence req
buffer)</strong> repeatedly to return the next chunk of data.&nbsp;
When there is no more data to read for this field, <strong>get-multipart-sequence</strong>
will return nil.&nbsp;&nbsp;&nbsp;&nbsp; If you're willing to store the
whole multipart data item in a lisp object in memory you can call <strong>get-all-multipart-data</strong>
instead to return the entire item in one Lisp object.</li>
  <li>go back to step 1</li>
</ol>
<p>It's important to retrieve all of the data sent with the form, even
if that data is
just ignored.&nbsp; This is because there may be another http request
following this one
and it's important to advance to the beginning of that request so that
it is properly
recognized.&nbsp;&nbsp; </p>
<p>Details on the functions are given next.</p>
<p>&nbsp;</p>
<hr>
<p><a name="f-get-multipart-header"></a><strong><font face="Courier New">(get-multipart-header
request)</font></strong></p>
<p>This returns nil or&nbsp; the MIME headers for the next form field
in alist form.
&nbsp;&nbsp;&nbsp; If nil is returned then there is no more form
data.&nbsp;&nbsp; See <strong>parse-multipart-header</strong>
for a simple way to extract information from the header.</p>
<p>For an input field such as <strong>&lt;input type="text"
name="textthing"&gt; </strong>the value returned by <strong>get-multipart-header</strong>
would be</p>
<pre>((:content-disposition<br>      (:param "form-data" ("name" . "textthing"))))</pre>
<p>For an input field such as <strong>&lt;input type="file"
name="thefile"&gt; </strong>the value returned by <strong>get-multipart-header</strong>
would be something like</p>
<pre>((:content-disposition<br>      (:param "form-data" ("name" . "thefile")<br>                          ("filename" . "C://down//550mhz.gif")))<br> (:content-type "image/gif"))</pre>
<p>Note that the filename is expressed in the syntax of the operating
system on which the
web browser is running.&nbsp; This syntax may or may not make sense to
the Lisp pathname
functions of the AllegroServe web server as it may be running on a
totally different
operating system.</p>
<p>&nbsp;</p>
<hr>
<p><a name="f-parse-multipart-header"></a><strong><font
 face="Courier New">(parse-multipart-header
header)</font></strong></p>
<p>This takes the value of get-multipart-header and returns values that
describe the
important information in the header.</p>
<p>The first value returned is </p>
<ul>
  <li><strong>:eof</strong>&nbsp; - this header says that there are no
more multipart items. &nbsp; This value is returned when the value of <strong>header









    </strong>is <strong>nil.</strong></li>
  <li><strong>:data</strong> - the next multipart item is a simple form
value.&nbsp; The second value returned is a string naming the
value.&nbsp; You can retrieve the value itself using repeated calls to <strong>get-multipart-sequence</strong>
or one call to <strong>get-all-multipart-data</strong>. </li>
  <li><strong>:file </strong>- the next multipart item is a file the
user is uploading to the server.&nbsp;&nbsp;&nbsp; The second value
returned in the name of the form item for which this file was
given.&nbsp; The third value is the name of the file as specified by
the user to his browser.&nbsp; The fourth value returned is the MIME
Content-Type that the browser is guessing applies to this contents of
the file.&nbsp;&nbsp; The contents of the file can be retrieved using
repeated calls to <strong>get-multipart-sequence</strong> or one call
to <strong>get-all-multipart-data</strong>. </li>
  <li><strong>:nofile</strong> - If a form contains a place for a
filename but no filename was entered before the form was submitted then
this type of header is sent.&nbsp; The values returned are the same as
those for <strong>:file <span style="font-weight: normal;">except</span>
    <span style="font-weight: normal;">that t</span></strong>he third
value (the filename) will always be the empty string.&nbsp; Just like
in the <span style="font-weight: bold;">:file</span> case you retrived
the contents with <span style="font-weight: bold;">get-multipart-sequence</span>
or <span style="font-weight: bold;">get-multipart-data</span>.<br>
  </li>
  <li><strong>nil</strong> - This header has a form not recognized by <strong>parse-multipart-header</strong>.
&nbsp;&nbsp;&nbsp;
If
you
encounter
this
please
let
us
know
about it
since we would like to enhance <strong>parse-multipart-header</strong>
to
understand this type of header. &nbsp;&nbsp; If you encounter
this&nbsp; type of header you still have to read the contents of the
data item that follows the header in order to read the next header.
&nbsp;&nbsp; A call to <strong>(get-all-multipart-data req :limit
1000) </strong>will read and throw away the following value so you can
then read the next header.</li>
</ul>
<hr>
<p><a name="f-get-multipart-sequence"></a><strong><font
 face="Courier New">(get-multipart-sequence
request buffer &amp;key start end external-format)</font></strong></p>
<p>This retrieves the next chunk of data for the current form field and
stores it in <strong>buffer</strong>.
&nbsp;&nbsp; If <strong>start</strong> is given then it specifies the
index in the buffer
at which to begin storing the data.&nbsp; If <strong>end</strong> is
given then it
specifies the index just after the last index in which to store data.</p>
<p>The return value is <strong>nil </strong>if there is no more data
to return, otherwise
it is the index one after the last&nbsp; index filled with data in <strong>buffer.</strong></p>
<p>The buffer can be a one dimensional array of <strong>character</strong>
or of <strong>(unsigned-byte
8)</strong>.&nbsp; For the most efficient transfer of data from the
browser to
AllegroServe, the program should use a 4096 byte (unsigned-byte 8)
array.</p>
<p>If the buffer is&nbsp; a character array then the data is converted
from
get-multipart-sequence's (unsigned-byte 8) array to characters using
the given<strong>
external-format </strong>(which defaults to<strong> </strong>the
value of <strong>*default-aserve-external-format*</strong>)<strong>.</strong></p>
<p><strong>get-multipart-sequence</strong> may return before filling up
the whole buffer,
so the program should be sure to make use of the index returned by <strong>get-multipart-sequence</strong>.</p>
<p>&nbsp;</p>
<hr>
<p><a name="f-get-all-multipart-data"></a><font face="Courier New"><strong>(get-all-multipart-data
request
&amp;key&nbsp;
type
size
external-format
limit)</strong></font></p>
<p>This retrieves the complete data object following the last multipart
header.
&nbsp;&nbsp; It returns it as a lisp object.&nbsp;&nbsp; If <strong>type</strong>
is<strong>
:text</strong> (the default) then the result is returned as a lisp
string.&nbsp;&nbsp; If <strong>type</strong>
is <strong>:binary</strong> then the result is returned as an array
of&nbsp; element-type
(unsigned-byte 8).&nbsp;&nbsp;&nbsp; <strong>size </strong>(which
defaults to 4096) is the
size of the internal buffers used by this function to retrieve the
data.&nbsp;&nbsp; You
usually won't need to specify a value for this but but if you know the
values retrieved
are either very small or very large it may make the operation run
faster
to specify an
appropriate <strong>size</strong>.&nbsp;&nbsp;&nbsp; <strong>external-format</strong>
is
used when <strong>type</strong> is <strong>:text</strong> to
convert&nbsp; the octet
stream into characters.&nbsp; It defaults to the value of <strong>*default-aserve-external-format*</strong>.
&nbsp;
<strong>limit </strong>can be given an integer value that
specifies the maximum
size of data you're willing to retrieve.&nbsp; By default there is no
limit.&nbsp; This
can be dangerous as a user may try to upload a huge data file which
will take up so much
Lisp heap space that it takes down the server.&nbsp;&nbsp; If a <strong>limit</strong>
is
given and that limit is reached, <strong>get-all-multipart-data</strong>
will continue to
read the data from the client until it reaches the end of the data,
however it will <em>not</em>
save it and will return the symbol <strong>:limit</strong> to indicate
that the data being
sent to the sever exceeded the limit.&nbsp; It will return a second
value which is the
size of the data the client tried to upload to the
server.&nbsp;&nbsp;&nbsp; If your
application intends to handle very large amounts of data being uploaded
to the server you
would be better off using <strong>get-multipart-sequence</strong>
since with that you can
write the data buffer by buffer to the disk instead of storing it in
the Lisp heap.</p>
<hr>
<p>&nbsp;</p>
<p>In AllegroServe the information sent to the web server as a result
of filling out a
form&nbsp; is called a <strong>query</strong>.&nbsp; We store a query
as a list of <strong>cons</strong>es,
where the <strong>car</strong> of the <strong>cons </strong>is the
name (a string) and the
<strong>cdr</strong> of the cons is the value (another
string).&nbsp;&nbsp;&nbsp; When a
query is transmitted by the web browser to AllegroServe it is sent as
string using the
encoding <strong>application/x-www-form-urlencoded.&nbsp; </strong>We
provide the
following functions to convert between the encoding and the query list:</p>
<p>&nbsp;</p>
<p><a name="f-form-urlencoded-"></a><font face="Courier New"><strong>(form-urlencoded-to-query
string
&amp;key
external-format)</strong></font></p>
<p>Decodes the string and returns the query list.&nbsp;&nbsp; The
default value for <strong>external-format</strong>
is the value of <strong>*default-aserve-external-format*</strong>.</p>
<p>&nbsp;</p>
<p><a name="f-query-to"></a><font face="Courier New"><strong>(query-to-form-urlencoded
query
&amp;key
external-format)</strong></font></p>
<p>Encodes the query and returns a string.&nbsp;&nbsp; The default
value for <strong>external-format</strong>
is the value of <strong>*default-aserve-external-format*.</strong></p>
<p>&nbsp;</p>
<p>Examples:</p>
<pre>user(4): <strong>(query-to-form-urlencoded '(("first name" . "joe") <br>                                     ("last name" . "smith")))</strong><br>"first+name=joe&amp;last+name=smith"<br><br>user(5): <strong>(form-urlencoded-to-query "first+name=joe&amp;last+name=smith")</strong><br>(("first name" . "joe") ("last name" . "smith"))<br> </pre>
<pre>user(6): <strong>(query-to-form-urlencoded<br>            `(("last name" . ,(coerce '(#\hiragana_letter_ta<br>                                        #\hiragana_letter_na<br>                                        #\hiragana_letter_ka)<br>                                      'string)))<br>              :external-format :euc)</strong><br> "last+name=%a4%bf%a4%ca%a4%ab"</pre>
<pre>user(7): <strong>(query-to-form-urlencoded<br>            `(("last name" . ,(coerce '(#\hiragana_letter_ta<br>                                        #\hiragana_letter_na<br>                                        #\hiragana_letter_ka)<br>                                      'string)))<br>             :external-format :shiftjis)</strong><br> "last+name=%82%bd%82%c8%82%a9"<br><br>user(8): <strong>(coerce<br>           (cdr<br>              (assoc "last name"<br>                (form-urlencoded-to-query "last+name=%82%bd%82%c8%82%a9"<br>                                      :external-format :shiftjis)<br>                :test #'equalp))<br>           'list)</strong><br> (#\hiragana_letter_ta #\hiragana_letter_na #\hiragana_letter_ka)<br></pre>
<hr>
<h2><a name="authorization"></a>Authorization </h2>
<p>You may want to restrict certain entities to be accessible from only
certain machines
or people.&nbsp;&nbsp; You can put the test for authorization in the
entity response
function using one of the following functions, or you can have the
check done
automatically by storing a list of <strong>authorizer</strong> objects
in the entity.</p>
<p>&nbsp;</p>
<h3>functions</h3>
<p>These two functions&nbsp; invoke and process the <em>Basic</em>
Authorization Method
&nbsp; defined by the http specification.&nbsp;&nbsp;&nbsp; The <strong>password-authorizer</strong>
class described below make use of these functions.</p>
<p><a name="f-get-basic-authorization"></a><strong><font
 face="Courier New">(get-basic-authorization
request)</font></strong></p>
<p>This function retrieves the Basic authorization information
associated with this
request, if any.&nbsp;&nbsp;&nbsp; The two returned values are the name
and password, both
strings.&nbsp; If there is no Basic authorization information with this
request, <strong>nil</strong>
is returned.</p>
<p>&nbsp;</p>
<p><a name="f-set-basic-authorization"></a><strong><font
 face="Courier New">(set-basic-authorization
request realm)</font></strong></p>
<p>This adds a header line that requests Basic authorization in the
given realm (a
string). &nbsp;&nbsp; This should be called between <strong>with-http-response</strong>
and <strong>with-http-body</strong> and only for response of type 401
(i.e. <strong>*response-unauthorized*</strong>).
&nbsp;&nbsp; The realm is an identifier, unique on this site, for the
set of pages for
which access should be authorized by a certain name and password.</p>
<p>&nbsp;</p>
<p>This example manually tests for basic authorization where the name
is <strong>foo</strong>
and the password is <strong>bar</strong>.</p>
<pre>(publish :path "/secret"<br>    :content-type "text/html"<br>    :function<br>    #'(lambda (req ent)<br>        (multiple-value-bind (name password) (<strong>get-basic-authorization</strong> req)<br>           (if* (and (equal name "foo") (equal password "bar"))<br>             then (with-http-response (req ent)<br>                    (with-http-body (req ent)<br>                      (html (:head (:title "Secret page"))<br>                            (:body "You made it to the secret page"))))<br>             else ; this will cause browser to put up a name/password dialog<br>                  (with-http-response (req ent :response *response-unauthorized*)<br>                     (<strong>set-basic-authorization</strong> req "secretserver")<br>                     (with-http-body (req ent)))))))<br><br></pre>
<h3>authorizer classes</h3>
<p>The authorizer slot of an entity object can contain a <strong>authorizer</strong>
object or a list of zero or more <strong>authorizer</strong>
objects.&nbsp; When a request
arrives for this entity the <strong>authorizer</strong> objects are
consulted to see if
this request should be permitted.&nbsp;&nbsp; In order for the request
to be permitted, <em>all</em>
authorizer objects must permit the request.&nbsp; AllegroServe supplies
three &nbsp;
interesting subclasses of <strong>authorizer</strong> and users are
free to add their own
subclasses to support their own authorization needs.&nbsp;&nbsp; </p>
<p>The protocol followed during authorization is this: </p>
<ol>
  <li>an entity object is selected that matches the request.&nbsp; The
value of the entity's authorizer slot is retrieved from the entity
object.</li>
  <li>if the list of pending authorizer objects is <strong>nil</strong>
then it is considered authorized.</li>
  <li>otherwise the <strong>authorize</strong> generic function is
called on the first <strong>authorizer</strong> object, passing <strong>authorize</strong>
the <strong>authorizer</strong> object, the http-request object and
the entity object</li>
  <li>the return value from <strong>authorize </strong>can be&nbsp; <br>
    <strong>t </strong>- meaning this request is authorized to access
this entity.&nbsp; In this case the first authorizer object is popped
from the list of pending authorizer objects and we go back to step 2.<br>
    <strong>nil - </strong>meaning that this request isn't
authorized.&nbsp; The response from AllegroServe will be the standard
"failed request" response so the user won't be able to distinguish this
response from one that would be received if the entity didn't exist at
all.<br>
    <strong>:deny</strong> - a denied request response will be
returned.&nbsp;&nbsp; It will <strong>not</strong> use the 401 return
code so this will not cause a password box to be displayed by the
browser.<br>
    <strong>:done</strong> - the request is denied, and a response has
already been sent to the requestor by the <strong>authorize </strong>function
so
no
further
response
should
be
made.</li>
</ol>
<p>&nbsp;</p>
<p><a name="c-password-authorizer"></a><strong>password-authorizer</strong>&nbsp;
[class]</p>
<p>This subclass of <strong>authorizer</strong> is useful if you want
to protect an entity
using the Basic authorization scheme that asks for a name and a
password.
&nbsp;&nbsp;&nbsp; When you create this class of object you should
supply values for the
two slots:</p>
<table border="1" width="100%">
  <tbody>
    <tr>
      <td width="13%"><big><strong>Slot Name</strong></big></td>
      <td width="11%"><big><strong>initarg</strong></big></td>
      <td width="76%"><big><strong>what</strong></big></td>
    </tr>
    <tr>
      <td width="13%"><strong>allowed</strong></td>
      <td width="11%">:<strong>allowed</strong></td>
      <td width="76%">list of conses, each cons having the form <strong>("name"
.
"password")







      </strong>where any of the listed name password pairs
will allow access to this page.</td>
    </tr>
    <tr>
      <td width="13%"><strong>realm</strong></td>
      <td width="11%"><strong>:realm</strong></td>
      <td width="76%">A string which names the protection space for the
given name and password. &nbsp; The realm will appear in the dialog box
the browser displays when asking for a name and password. </td>
    </tr>
  </tbody>
</table>
<p>An example of its use is the following where we allow access only
if the user enters a
name of <strong>joe</strong> and a password of <strong>eoj</strong>
or a name of <strong>fred</strong>
and a password of<strong> derf</strong>.</p>
<pre>  (publish :path "/foo"<br>    :content-type "text/html"<br>    :authorizer (make-instance 'password-authorizer<br>                       :allowed '(("joe" . "eoj")<br>                                  ("fred" . "derf"))<br>                       :realm "SecretAuth")<br><br>    :function<br>    #'(lambda (req ent)<br>        (with-http-response (req ent)<br>           (with-http-body (req ent)<br>              (html (:head (:title "Secret page"))<br>                    (:body "You made it to the secret page"))))))</pre>
<p>&nbsp;</p>
<p><a name="c-location-authorizer"></a><strong>location-authorizer</strong>
[class]</p>
<p>This authorizer class checks the IP address of the request to see if
it is permitted
access to the entity.&nbsp; The&nbsp; authorizer can specify a sequence
of&nbsp; patterns
and for each pattern a command of <strong>:accept </strong>(permit
the access) or <strong>:deny</strong>
(forbid the access).&nbsp;&nbsp;&nbsp; The first pattern that matches
determines if the
request is accepted or denied.&nbsp; If the pattern list is empty or if
no pattern
matches, then the request is accepted.&nbsp; </p>
<p>The single slot of an object of class <strong>location-authorizer</strong>
is</p>
<table border="1" width="100%">
  <tbody>
    <tr>
      <td width="13%"><big><strong>Slot Name</strong></big></td>
      <td width="11%"><big><strong>initarg</strong></big></td>
      <td width="76%"><big><strong>what</strong></big></td>
    </tr>
    <tr>
      <td width="13%"><strong>patterns</strong></td>
      <td width="11%">:<strong>patterns</strong></td>
      <td width="76%">a list of patterns and commands, where the syntax
of a pattern-command is described below.</td>
    </tr>
  </tbody>
</table>
<p>A pattern can be </p>
<ul>
  <li><strong>:accept</strong> -- this is a pattern that matches all IP
addresses and causes the access to be authorized</li>
  <li><strong>:deny</strong> -- this is a pattern that matches all IP
addresses and causes the access to be rejected</li>
  <li><strong>(:accept ipaddress [bits])</strong> --&nbsp; if the
request's IP address matches the most significant <strong>bits</strong>
of <strong>ipaddress</strong> then this access is
accepted.&nbsp;&nbsp; <strong>bits</strong> is optional and defaults
to 32 (the whole address).&nbsp; The ipaddress can be an integer (the
32 bit IP address) or it can be a string in either dotted form
"123.23.43.12"&nbsp; or a host name "foo.bar.com".&nbsp;&nbsp; In the
case of a host name, a lookup must be done to map the host name to
an&nbsp; IP address.&nbsp;&nbsp; If this lookup fails then it is
assumed that the pattern doesn't match.&nbsp;&nbsp; If <strong>ipaddress</strong>
is a string, then the first time it is examined during authorization it
is converted to an integer IP address and that value replaces the
string in the pattern (thus caching the result of the conversion to an
IP address).</li>
  <li><strong>(:deny ipaddress [bits])</strong> -- just like the case
above except the request is rejected if it matches the <strong>ipaddress</strong>.&nbsp;&nbsp;
One
difference
is
this:
if
the



    <strong>ipaddress </strong>is a host
name and that host name cannot be translated to an IP address, then it
is assumed to match, and thus the request will be denied.&nbsp; </li>
</ul>
<p>The example of using a <strong>location-authorizer</strong> only
permits connections
coming in via the loopback network (which occurs if you specify <a
 href="http://localhost/whatever">http://localhost/whatever</a>) or if
they come from one
particular machine (tiger.franz.com).&nbsp; Note that we end the
pattern list with <strong>:deny</strong>
so that anything not matching the preceding patterns will be denied.</p>
<pre>(publish :path "/local-secret-auth"<br>    :content-type "text/html"<br>    :authorizer (make-instance 'location-authorizer<br>                         :patterns '((:accept "127.0" 8)<br>                                     (:accept "tiger.franz.com")<br>                                     :deny))<br><br>    :function<br>    #'(lambda (req ent)<br>        (with-http-response (req ent)<br>           (with-http-body (req ent)<br>               (html (:head (:title "Secret page"))<br>                     (:body (:b "Congratulations. ")<br>                       "You made it to the secret page"))))))<br><br></pre>
<p><strong><a name="c-function-authorizer"></a>function-authorizer </strong>&nbsp;
[class]</p>
<p>This authorizer contains a function provided by the user which is
used to test if the
request is authorized.&nbsp;&nbsp; The function take three arguments,
the http-request
object, the entity and the authorizer object.&nbsp;&nbsp; It must
return one of the four
values that the <strong>authorize</strong> function returns, namely <strong>t,
nil
:deny</strong>
or <strong>:done.</strong></p>
<p>A function-authorizer is created as follows</p>
<pre>(make-instance 'function-authorizer<br>    :function #'(lambda (req ent auth)<br>                          t  ; always authorize<br>                 ))</pre>
<p>The function slot can be set using (setf
function-authorizer-function) if you wish to
change it after the authorizer has been created.</p>
<p>&nbsp;</p>
<h2><a name="cookies"></a>Cookies</h2>
<p>Cookies are name value pairs that a web server can direct a web
browser to save and
then pass back to the web server under certain
circumstances.&nbsp;&nbsp; Some users
configure their web browsers to reject cookies, thus you are advised
against building a
site that depends on cookies to work.</p>
<p>Each cookie has these components: </p>
<ol>
  <li><strong>name</strong> - a string.&nbsp;&nbsp; Since you can get
multiple cookies sent to you by a web browser, using a unique name will
allow you to distinguish the values.</li>
  <li><strong>value</strong> - a string</li>
  <li><strong>path</strong> - a string which must be the prefix of the
request from the web browser for this cookie to be sent.&nbsp; The
string "/" is the prefix of all requests.</li>
  <li><strong>domain </strong>- a string which must be the suffix of
the name of the machine where the request is being sent in order for
this cookie to be sent.</li>
  <li><strong>expiration</strong> - a time when this cookie expires. </li>
  <li><strong>secure</strong> - either true or false.&nbsp; If true
then this cookie will only be sent if the connection is through a
secure socket</li>
</ol>
<p>&nbsp;</p>
<p><a name="f-set-cookie-header"></a><strong><font face="Courier New">(set-cookie-header
request
&amp;key
name
value
expires
domain
path
secure
encode-value
external-format)</font></strong></p>
<p>This function must be called before <strong>with-http-body</strong>.&nbsp;&nbsp;
It
can
be
called
more
than
once.&nbsp;
Each
call
will
cause one Set-Cookie directive to be sent to the web browser.
&nbsp;&nbsp;&nbsp;
The <strong>name</strong> and <strong>value</strong> arguments should
be given (and they
should be strings).&nbsp; They will be automatically encoded using the
same encoding used
in urls (we call it <em>uriencoding). </em>The purpose of this
encoding is to convert
characters that are either unprintable or those that have a special
meaning into a
printable string.&nbsp;&nbsp;&nbsp; The web browser doesn't care about
the <strong>name</strong>
and <strong>value</strong>, it just stores them and sends them back to
the web server.
&nbsp;&nbsp;&nbsp; If you use the <strong>get-cookie-values </strong>function
to
retrieve
the
cookie
<strong>name</strong> and <strong>value</strong> pairs,
then it will
automatically decode the uriencoding.</p>
<p>You can disable the encoding of the value by specifying a <strong>nil</strong>
value to
<strong>encode-value</strong>.&nbsp;&nbsp;&nbsp; This should only be
necessary if you are
working with buggy http client applications.<br>
<br>
If the <strong>path </strong>argument isn't given, it will default to
"/" which
will allow this cookie to match all requests.<br>
If the <strong>domain</strong> argument isn't given then it will
default to the host to
which this request was sent.&nbsp; If you wish to specify this you are
only allowed to
specify a subsequence of the host to which this request was sent (i.e
the name of the
machine running the webserver).&nbsp;&nbsp; The <strong>domain</strong>
should have at
least two periods in it (i.e.&nbsp; ".foo.com").<br>
<strong>expires</strong> can be a lisp universal time or it can be the
symbol <strong>:never</strong>
meaning this should never expire.&nbsp; If <strong>expires </strong>isn't
given
or
is
<strong>nil</strong>
then this cookie will expire when the user quits their web browser.<br>
<strong>secure</strong> should be true or false.&nbsp; Any non-nil
value is interpreted as
true. The default value is false.<br>
The <strong>external-format</strong> is used to convert bytes to
characters. &nbsp; It
defaults to the value of <strong>*default-aserve-external-format*</strong>.
</p>
<p>&nbsp;</p>
<p><a name="f-get-cookie-values"></a><strong><font face="Courier New">(get-cookie-values
request
&amp;key
external-format)</font></strong></p>
<p>Return the cookie <strong>name</strong> and <strong>value</strong>
pairs from the
header of the request.&nbsp;&nbsp; Each <strong>name</strong> <strong>value</strong>
pair
will be in a cons whose <strong>car</strong> is the <strong>name</strong>
and whose <strong>cdr</strong>
is the <strong>value</strong>.&nbsp;&nbsp; The names and values will
be decoded (in other
words the decoding done by <strong>set-cookie-header</strong> will be
undone).
&nbsp;&nbsp; The <strong>external-format</strong> is used to convert
bytes to characters.
&nbsp; It defaults to the value of <strong>*default-aserve-external-format*</strong>.
</p>
<p>&nbsp;</p>
<hr>
<h2><a name="varaibles"></a>Variables</h2>
<p>These special variables contain&nbsp; information about AllegroServe
or help control
AllegroServe:</p>
<p><a name="v-aserve-version"></a><strong><font face="Courier New">*aserve-version*</font></strong>
- a list of three values: (major-version minor-version
sub-minor-version) which is usually
printed with periods separating the values (i.e. X.Y.Z).</p>
<p><a name="v-default-aserve-external-format"></a><strong><font
 face="Courier New">*default-aserve-external-format*</font></strong>
- a symbol or external format object which is the default value for
those AllegroServe
functions that take an external-format argument.&nbsp;&nbsp; http
requests are normally
run in separate lisp threads and those threads bind
*default-aserve-external-format* to
the value of the external-format argument to the start
function.&nbsp;&nbsp; Thus changing
the value of *default-aserve-external-format* in one thread will not
affect its value in
other threads.&nbsp;&nbsp; You should decide the default external
format before you start
AllegroServe running.</p>
<p><a name="v-http-response-timeout"></a><strong><font
 face="Courier New">*http-response-timeout*</font></strong>
- the default value for the timeout argument to
with-http-response.&nbsp;&nbsp; [in future
versions of AllegroServe we'll treat this value like
*default-aserve-external-format* and
bind it in each worker thread]</p>
<p><a name="v-mime-types"></a><strong><font face="Courier New">*mime-types*</font></strong>
- a hash table where the keys are the file types (e.g. "jpg") and the
values are
the MIME types (e.g. "image/jpeg").</p>
<p>&nbsp;</p>
<hr>
<h2><a name="iseve-request-proc"></a>AllegroServe request processing
protocol</h2>
<p>We'll describe here the steps AllegroServe goes through from the
time it receives a
request until a response to that request has been sent back to the
browser.&nbsp;&nbsp;&nbsp; We want the protocol to be open so that
users can extend
AllegroServe's behavior to suit their needs.&nbsp; However given that
AllegroServe is a
new program and will be undergoing extensive review from its users, we
expect that the
protocol will change.&nbsp;&nbsp; It shouldn't lose any of its current
extensibility but
the names and argument lists of generic functions may change.&nbsp; </p>
<p>When a client connects to the port on which AllegroServe is
listening, AllegroServe
passes that connected socket to a free worker thread which then wakes
up and calls the
internal function <strong>net.aserve::process-connection</strong>.&nbsp;&nbsp;
If
there
are
no
free
worker
threads
then
AllegroServe
waits
for one to be
available.</p>
<p>In each worker thread the variable <strong>*wserver*</strong> is
bound to the <strong>wserver</strong>
object that holds all the information about the webserver on which the
connection was made
(remember that one AllegroServe process can be running more than one
webserver).&nbsp;&nbsp; <strong>process-connection</strong> reads the
request from the
socket (but doesn't read past the header lines). &nbsp;&nbsp;&nbsp; If
the request can't
be read within <strong>*read-request-timeout* </strong>seconds
(currently 20) then the
request is rejected.&nbsp;&nbsp;&nbsp; The request is stored in an
object of class <strong>http-request</strong>.&nbsp;&nbsp;&nbsp;
Next <strong>process-connection</strong> calls <strong>handle-request</strong>
to do all
the work of the request and then <strong>log-request</strong> to log
the action of the
request.&nbsp; Finally if the response to the request indicated that
the connection was to
be kept open rather than being closed after the response, then <strong>process-connection</strong>
loops back to the top to read the next request.</p>
<p>&nbsp;</p>
<p><a name="f-handle-request"></a><strong><font face="Courier New">(handle-request
(req
http-request))</font></strong> &nbsp;&nbsp; [generic function]</p>
<p>This generic function must locate the entity to handle this request
and then cause it
to respond to the request.&nbsp;&nbsp; If there is no matching entity
then <strong>handle-request</strong>
must send a response back to the client itself.&nbsp; <strong>handle-request</strong>
uses
locators to find the entity (more on this below), and then if an entity
is found and that
entity has an authorizer, it calls <strong>authorize</strong> to see
if this request is
allowed to access the selected entity.&nbsp; If the entity passes the
authorization then <strong>process-entity</strong>
is called to cause the entity to respond to the request.&nbsp; <strong>process-entity</strong>
returns true if it processed the entity, and nil if did not in which
case the search
continues for an entity.&nbsp; If there is no entity to respond then <strong>failed-request</strong>
is called to send back a failure message.</p>
<p>A <strong>locator</strong> is an object used to map requests into
entities.
&nbsp;&nbsp; The value of <strong>(wserver-locators *wserver*)</strong>
is a list of
locator objects.&nbsp;&nbsp; <strong>handle-request</strong> calls </p>
<p><a name="f-standard-locator"></a><strong><font face="Courier New">(standard-locator
(req
http-request)
(loc
locator))
</font></strong>[generic function]</p>
<p>on each successive locator in that list until one returns an entity
object.
&nbsp;&nbsp;&nbsp; AllegroServe has two built-in locator classes, <strong>locator-exact</strong>
and <strong>locator-prefix</strong>, that are subclasses of <strong>locator.&nbsp;&nbsp;
</strong>When
you call <strong>publish</strong> or <strong>publish-file</strong>
you are adding the
entity to locator of class <strong>locator-exact</strong> found in the
<strong>wserver-locators
</strong>list.&nbsp;&nbsp; When you call <strong>publish-directory</strong>
you are adding
to the locator of class <strong>locator-prefix.</strong>&nbsp;&nbsp;&nbsp;
Users
are
free
to
define
new
locator
classes.&nbsp;&nbsp;&nbsp;
Locators
should
define
the <strong>standard-locator</strong>
method as well as </p>
<p><a name="f-unpublish-locator"></a><strong><font face="Courier New">(unpublish-locator
(loc
locator))</font></strong> &nbsp;&nbsp; [generic&nbsp; function]</p>
<p>which if called should remove all published entities from the
locator.</p>
<p>&nbsp;</p>
<p>Let's return to <strong>handle-request.</strong>&nbsp; It has
called <strong>standard-locator</strong>
and found an entity.&nbsp;&nbsp; Next it checks to see if the entity
has an authorizer
value and if so calls</p>
<p><a name="f-authorize"></a><strong><font face="Courier New">(authorize
(auth
authorizer)
(req
http-request)
(ent
entity))
</font></strong>&nbsp; [generic
function]</p>
<p>The return value will be one of </p>
<ul>
  <li><strong>t -- </strong>The request is authorized,&nbsp; call <strong>process-entity</strong>
to make the entity respond.</li>
  <li><strong>nil</strong> -- The request is not authorized, call <strong>failed-request









    </strong>to send back a response.</li>
  <li><strong>:deny</strong> -- The request is denied and we want the
user to know that it was denied rather than sending a generic failed
message, call <strong>denied-request</strong> to send back a response.</li>
  <li><strong>:done</strong> -- The <strong>authorize</strong>
function has sent back a response, there is nothing more for <strong>handle-request</strong>
to do for this request.</li>
</ul>
<p>If there is no authorizer for this entity then we just call <strong>process-entity.</strong>
&nbsp;&nbsp; If there is no entity, then we call <strong>failed-request</strong>.
</p>
<p>&nbsp;</p>
<p><a name="f-failed-request"></a><strong><font face="Courier New">(failed-request
(req
http-request))</font></strong> &nbsp;&nbsp; [generic function]</p>
<p>send back a response to the effect that the url request doesn't
exist on this server.</p>
<p>&nbsp;</p>
<p><a name="f-denied-request"></a><strong><font face="Courier New">(denied-request
(req
http-request))</font></strong> &nbsp; [generic function]</p>
<p>send back a response to the effect that access to the requested url
was denied. </p>
<p>&nbsp;</p>
<p><a name="f-process-entity"></a><strong><font face="Courier New">(process-entity&nbsp;
(req
http-request)
(ent
entity))</font></strong> &nbsp;&nbsp; [generic
function]</p>
<p>Send back a response appropriate to the given
entity.&nbsp;&nbsp;&nbsp;&nbsp; The
macros with-http-response and with-http-body should be used in the code
that sends the
response.</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<hr>
<h2><a name="client-request"></a>Client functions</h2>
<p>AllegroServe has a set of functions that perform http client-side
actions.&nbsp;&nbsp;
These functions are useful in generating computed pages that reflect
the contents of other
pages.&nbsp; We also use the client-side http functions to test
AllegroServe.</p>
<p>The client-side functions described in this section are exported
from the<font face="Courier New"> net.aserve.client</font> package.</p>
<p>The function <strong>do-http-request </strong>sends a request and
retrieves the whole
response.&nbsp;&nbsp;&nbsp; This is the most convenient function to use
to retrieve a web
page.</p>
<p>If you need more control over the process you can use the functions:
<strong>make-http-request</strong>,
<strong>read-client-response-headers </strong>and <strong>client-request-read-sequence</strong>.</p>
<p>&nbsp;</p>
<p><a name="f-do-http-request"></a><strong><font face="Courier New">(do-http-request
uri
&amp;key
method
protocol
accept
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
content
content-type
query
format
cookies
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
redirect
redirect-methods
basic-authorization<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
digest-authorization<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
keep-alive
headers
proxy
proxy-basic-authorization<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
user-agent
external-format
ssl
ssl-method<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
skip-body
timeout
compress
keep-alive
connection<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
certificate
key
certificate-password
ca-file
ca-directory
verify
max-depth)</font></strong></p>
<p>Sends a request to <strong>uri</strong> and returns four values: </p>
<ol>
  <li>The body of the response.&nbsp; If there is no body the empty
string is returned.</li>
  <li>the response code (for example, 200, meaning that the request
succeeded)</li>
  <li>an alist of headers where the <strong>car</strong> of each entry
is a keyword symbol or a lowercase string with the header name and the <strong>cdr</strong>
is a string with the value of that header item.&nbsp;&nbsp; A keyword
symbol is returned for standard headers.<br>
  </li>
  <li>the uri object denoting the page accessed.&nbsp; This is normally
computed from the <strong>uri</strong> value passed in but if
redirection was done then this reflects the target of the
redirection.&nbsp; If you plan to interpret relative html links in the <strong>body</strong>
returned then you must do so with respect to <em>this</em> uri value </li>
  <li>If a true value for the <span style="font-weight: bold;">:keep-alive</span>
argument was given then this will be socket connection to the server if
the server chose to accept the keep-alive request.&nbsp; This socket
can be used as the value of the <span style="font-weight: bold;">:connection</span>
argument in a subsequent call to do-http-request to the same server.</li>
</ol>
<p>The <strong>uri</strong> can be a uri object or a
string.&nbsp;&nbsp; The scheme of the
<strong>uri</strong> must be nil or "http".&nbsp;&nbsp; The keyword
arguments to
<strong>do-http-request </strong>are</p>
<table border="1" width="100%">
  <tbody>
    <tr>
      <th width="22%">Name</th>
      <th width="16%">default</th>
      <th width="62%">description</th>
    </tr>
    <tr>
      <td width="22%">method</td>
      <td width="16%">:get</td>
      <td width="62%">The type of request to make.&nbsp; Other possible
values are <strong>:put</strong>, <strong>:post</strong> and<strong>
:head</strong>.&nbsp; <strong>:head</strong> is useful if you just
want to see if the link works without downloading the data.</td>
    </tr>
    <tr>
      <td width="22%">protocol</td>
      <td width="16%">:http/1.1</td>
      <td width="62%">The other possible value is <strong>:http/1.0</strong>.&nbsp;
Modern
web
servers
will
return
the
response
body
in
chunks if told to
use the <strong>:http/1.1</strong> protocol.&nbsp; Buggy web servers
may do chunking incorrectly (even Apache has bugs in this regard but
we've worked around them).&nbsp; If you have trouble talking to a web
server you should try specifying the <strong>:http/1.0</strong>
protocol to see if that works.</td>
    </tr>
    <tr>
      <td width="22%">accept</td>
      <td width="16%">"*/*"</td>
      <td width="62%">A string listing of MIME types that are
acceptable as a response to this request.&nbsp; The type listed can be
simple such as "text/html" or more complex like "text/html,
audio/*"&nbsp; The default is to accept anything which is expressed
"*/*".</td>
    </tr>
    <tr>
      <td width="22%">content</td>
      <td width="16%">nil</td>
      <td width="62%">If the method is <strong>:put</strong> or<strong>
:post</strong> then the request should include something to be sent to
the web server.&nbsp;&nbsp; The value of this argument is either a
string or a vector of type (unsigned-byte 8) which will be sent to the
web server.&nbsp;&nbsp; It may also be a list of strings or vectors.
See the <strong>query</strong> argument for a more convenient way to <strong>:post</strong>
data to a form.</td>
    </tr>
    <tr>
      <td width="22%">content-type</td>
      <td width="16%">nil</td>
      <td width="62%">A string which is to be the value of the
Content-Type header field, describing the format of the value of the <strong>content</strong>
argument. &nbsp;&nbsp; This is only needed for <strong>:put</strong>
and <strong>:post</strong> requests.</td>
    </tr>
    <tr>
      <td width="22%">query</td>
      <td width="16%">nil</td>
      <td width="62%">This is a query alist of the form suitable for <strong>query-to-form-urlencoded</strong>.
&nbsp;
If
the
method
is
a



      <strong>:get</strong> then the value
of&nbsp; this argument is <strong>urlencoded</strong> and made the
query string of the uri being accessed.&nbsp; If the method is <strong>:post</strong>
then the query string is <strong>urlencoded</strong> and made the <strong>content</strong>
of the request.&nbsp; Also the <strong>content-type</strong> is set to
      <strong>application/x-www-form-urlencoded.</strong> </td>
    </tr>
    <tr>
      <td width="22%">format</td>
      <td width="16%">:text</td>
      <td width="62%">The body of the response is returned as a string
if the value is<strong> :text </strong>or as an array of type
(unsigned-byte 8) if the value is <strong>:binary</strong>.
&nbsp;&nbsp; When the body is a string the external-format argument is
important.</td>
    </tr>
    <tr>
      <td width="22%">cookies</td>
      <td width="16%">nil</td>
      <td width="62%">If you wish the request to include applicable
cookies and for returned cookies to be saved, then a <strong>cookie-jar</strong>
object should be passed as the value of this argument.</td>
    </tr>
    <tr>
      <td width="22%">redirect</td>
      <td width="16%">5</td>
      <td width="62%">If the response is a redirect (code 301, 302,
303), and the method is one given by the value of <strong>redirect-methods









      </strong>then if this argument is true (and, if an integer,
positive), <strong>do-http-request</strong> will call itself to access
the page to which the redirection is pointed.&nbsp; If <strong>redirect</strong>
is an integer then in the recursive call the value passed for <strong>redirect</strong>
will be one less than the current value.&nbsp; This prevents infinite
recursion due to redirection loops.</td>
    </tr>
    <tr>
      <td width="22%">redirect-methods</td>
      <td width="16%">(:get :head)</td>
      <td width="62%">List of http methods which will be redirected if <strong>redirect</strong>
is true.</td>
    </tr>
    <tr>
      <td width="22%">basic-authorization</td>
      <td width="16%">nil</td>
      <td width="62%">If given, it is a cons whose <strong>car</strong>
is the name and whose <strong>cdr </strong>is the password to be used
to get authorization to access this page.</td>
    </tr>
    <tr>
      <td style="vertical-align: top;">digest-authorization<br>
      </td>
      <td style="vertical-align: top;">nil<br>
      </td>
      <td style="vertical-align: top;">If given it is a <span
 style="font-weight: bold;">digest-authorization</span> object with
values in the <span style="font-weight: bold;">username</span> and <span
 style="font-weight: bold;">password</span> slots.&nbsp; The
digest-authorization object will be modified by do-http-request in
order to store the information needed to send as authorization
credentials.<br>
      </td>
    </tr>
    <tr>
      <td width="22%">keep-alive</td>
      <td width="16%">nil</td>
      <td width="62%">If true then the web server will be told to keep
the connection alive. &nbsp;&nbsp; Since <strong>do-http-request</strong>
closes the connection after the request this option currently does no
more than allow us to experiment with how a web server responds to a
keep-alive request.</td>
    </tr>
    <tr>
      <td width="22%">headers</td>
      <td width="16%">nil</td>
      <td width="62%">an alist of conses <font face="Courier New">(header-name
.
"header-value")</font> for additional headers to send with the
request.&nbsp;&nbsp; The header-name should be a keyword symbol naming
the header, but it can be a string as well.<br>
      </td>
    </tr>
    <tr>
      <td width="22%">proxy</td>
      <td width="16%">nil</td>
      <td width="62%">the name and optionally the port number of a
proxying web server through which this request should be
made.&nbsp;&nbsp; The form is of the argument is <a
 href="http://www.machine.com">"www.machine.com"</a> or <a
 href="http://www.machine.com:8000">"www.machine.com:8000"</a> if the
web server is listening on port 8000 rather than 80.&nbsp;&nbsp;
Proxying web servers are often used when clients are behind firewalls
that prevent direct access to the internet. &nbsp; Another use is to
centralize the page cache for a group of clients.</td>
    </tr>
    <tr>
      <td style="vertical-align: top;">proxy-basic-authorization<br>
      </td>
      <td style="vertical-align: top;">nil<br>
      </td>
      <td style="vertical-align: top;">a cons of ("name" . "password")
used to authenticate this request to the proxy being used.<br>
      </td>
    </tr>
    <tr>
      <td width="22%">user-agent</td>
      <td width="16%">nil</td>
      <td width="62%">If given it specifies the value of the User-Agent
header to be sent with the request.&nbsp; Some sites respond
differently based on the user-agent they believe has made the
request.&nbsp; The lack of a User-Agent header may cause a server to
ignore a request since it believes that it is being probed by a
robot.&nbsp; The value of user-agent can be a string or one of the
keywords <strong>:aserve</strong>, <strong>:netscape</strong> or <strong>:ie</strong>
in which case an appropriate user agent string is sent.</td>
    </tr>
    <tr>
      <td width="22%">external-format</td>
      <td width="16%">the value of <strong>*default-aserve-external-format*</strong></td>
      <td width="62%">This determines the socket stream's external
format.</td>
    </tr>
    <tr>
      <td style="vertical-align: top;">keep-alive<br>
      </td>
      <td style="vertical-align: top;">nil<br>
      </td>
      <td style="vertical-align: top;">if true then the client will
request that the server keep alive the connection.&nbsp; If the server
agrees then that socket connection is returned as the fifth value.<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">connection<br>
      </td>
      <td style="vertical-align: top;">nil<br>
      </td>
      <td style="vertical-align: top;">If non nil then this is a socket
connected to the server for which this request is made.&nbsp; If the
socket is not valid (likely due to the server closing its end) then a
new socket will be created.&nbsp; Thus it is not an error.<br>
      </td>
    </tr>
    <tr>
      <td width="22%">ssl</td>
      <td width="16%">nil</td>
      <td width="62%">If true then the connection is made using the
Secure Sockets Layer protocol.&nbsp;&nbsp;&nbsp; If the uri uses the <strong>https</strong>
scheme then <strong>ssl</strong> is assumed to be true and the <strong>ssl









      </strong>argument need not be specified.</td>
    </tr>
    <tr>
      <td style="vertical-align: top;">ssl-method<br>
      </td>
      <td style="vertical-align: top;">nil</td>
      <td style="vertical-align: top;"><span style="font-weight: bold;"></span>see







      <a href="aserve.html#ssltls">SSL/TLS</a> for the use of this
argument.<br>
      </td>
    </tr>
    <tr>
      <td width="22%">skip-body</td>
      <td width="16%">nil</td>
      <td width="62%">If the value is a fucntion (satisifies <strong>functionp</strong>)
then
the
value
is
funcalled
passing
the


      <strong>client-request </strong>object
as
an argument. &nbsp; At this point the client-request object contains
the information on the headers of the response.&nbsp;&nbsp; The
function should return true if the body of the response should be
skipped and <strong>nil</strong> returned as the first value from
do-http-request.&nbsp; If skip-body is not a function and if its value
is true then reading the body is skipped and <strong>nil</strong>
returned in its place.</td>
    </tr>
    <tr>
      <td style="vertical-align: top;">timeout<br>
      </td>
      <td style="vertical-align: top;">nil<br>
      </td>
      <td style="vertical-align: top;">If given this is the number of
seconds this function will block waiting to connect to the server and
also to write or read to the socket
connected to the web server.&nbsp;&nbsp; If an I/O request blocks for
more than timeout seconds an error of class <span
 style="font-weight: bold;">socket-error</span> is signalled and the
function <span style="font-weight: bold;">stream-error-identifier</span>
on the error condition object will return <span
 style="font-weight: bold;">:read-timeout</span> or <span
 style="font-weight: bold;">:write-timeout</span>.<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">compress<br>
      </td>
      <td style="vertical-align: top;">nil<br>
      </td>
      <td style="vertical-align: top;">If true then tell the server in
the request that we are able to accept a compressed body.&nbsp; If the
server decides to send a compressed body then the body will be
uncompressed by do-http-request before being returned to the caller.<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">certificate, key,<br>
certificate-password, ca-file,<br>
ca-directory, verify, max-depth<br>
      </td>
      <td style="vertical-align: top;">nil<br>
      </td>
      <td style="vertical-align: top;">These values are passed as the
arguments to make-ssl-client-stream (documented in the ACL
documentation).&nbsp; Specifying these values is optional but it does
give you control of the client's SSL certificate management.<br>
These values are used in a fully patched ACL 8.0 (or newer).&nbsp; In
older versions of ACL they are ignored.<br>
      </td>
    </tr>
  </tbody>
</table>
<p>&nbsp;</p>
<p>For example:</p>
<pre>user(5): <strong>(do-http-request "http://www.franz.com")</strong><br></pre>
<pre>"&lt;HTML&gt;<br>    &lt;HEAD&gt;<br>        &lt;TITLE&gt;Franz Inc: Allegro Common Lisp and Common Lisp Products&lt;/TITLE&gt;<br>        &lt;BASE FONTFACE=\"helvetica, arial\" FONTSIZE=\"1\"&gt;<br>.....</pre>
<pre>"<br>200<br>(("content-type" . "text/html") ("transfer-encoding" . "chunked")<br>("server" . "Apache/1.3.9 (Unix) PHP/3.0.14")<br>("date" . "Mon, 24 Apr 2000 11:00:51 GMT"))<br></pre>
<p>&nbsp;</p>
<p>It's easy to use <strong>do-http-request</strong> to fill in form
objects on a page.
&nbsp; If the form has input elements named&nbsp; <strong>width</strong>
and <strong>height</strong>
then you can send a request that specifies that information in this way:</p>
<pre><font face="Courier New">(do-http-request <a
 href="http://www.foo.com/myform.html">"http://www.foo.com/myform.html"</a> <br>                 :query '(("width" . 23) ("height" . 45)))</font></pre>
<p>The above assumes that the method on the form is "GET".&nbsp;&nbsp;
If the
method is "POST" then a similar call will work:</p>
<pre><font face="Courier New">(do-http-request <a
 href="http://www.foo.com/myform.html">"http://www.foo.com/myform.html"</a>  <strong>:method :post</strong><br>                 :query '(("width" . 23) ("height" . 45)))</font></pre>
<p><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
If the page uses digest authorization then you would call with
arguments like<br>
</p>
<pre>(do-http-request "http://www.secret.com/whatever.html"<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :digest-authorization (make-instance 'digest-authorization :username "joe" :password "secret"))<br></pre>
<p><br>
</p>
<p>&nbsp;</p>
<p>Before we describe the lower level client request functions we will
describe two
classes of objects used in that interface.</p>
<h2><a name="c-client-request"></a>client-request</h2>
<p>A <strong>client-request</strong> object includes the information
about the request and
the response.</p>
<p>The public fields of a <strong>client-request</strong> that are
filled in after a call
to <strong>make-http-client-request</strong> are:</p>
<table border="1" width="100%">
  <tbody>
    <tr>
      <th width="31%">Accessor</th>
      <th width="69%">Description</th>
    </tr>
    <tr>
      <td width="31%">client-request-uri</td>
      <td width="69%">uri object corresponding to this request</td>
    </tr>
    <tr>
      <td width="31%">client-request-socket</td>
      <td width="69%">socket object open to the web server denoted by
the uri</td>
    </tr>
    <tr>
      <td width="31%">client-request-cookies</td>
      <td width="69%">the cookie-jar object (if any) passed in with
this request.</td>
    </tr>
  </tbody>
</table>
<p>&nbsp;</p>
<p>After <strong>read-client-response-headers</strong> is called, the
following fields of
the <strong>client-request</strong> objects are set:</p>
<table border="1" width="100%">
  <tbody>
    <tr>
      <th width="39%">Accessor</th>
      <th width="61%">Description</th>
    </tr>
    <tr>
      <td width="39%">client-request-response-code</td>
      <td width="61%">the integer that is the response code for this
request.&nbsp; The most common codes are 200 for Success and 404 for
Not Found.</td>
    </tr>
    <tr>
      <td width="39%">client-request-headers</td>
      <td width="61%">an alist of header values in the response.&nbsp;
Each entry is a cons of the form <font face="Courier New">("header-name"
.
"header-value")</font> or (:header-name . "header-value") for well
known slots. &nbsp; The header names, if strings,&nbsp; are in all
lower case.</td>
    </tr>
    <tr>
      <td width="39%">client-request-protocol</td>
      <td width="61%">A keyword symbol naming the protocol&nbsp; that
the web server returned (which may be different that the protocol given
in the request).&nbsp;&nbsp; A typical return value is <strong>:http/1.1</strong></td>
    </tr>
    <tr>
      <td width="39%">client-request-response-comment</td>
      <td width="61%">A string giving a textual version of the response
code.&nbsp;&nbsp; The string is arbitrary and you should not depend on
all web servers returning the same string for any given response code.</td>
    </tr>
  </tbody>
</table>
<p>&nbsp;</p>
<h2><a name="c-cookie-jar"></a>cookie-jar</h2>
<p>A <strong>cookie-jar</strong> is a respository for cookies.&nbsp;
Cookies are stored in
a jar when a response from a client request includes <font
 face="Courier New">Set-Cookie</font>
headers.&nbsp;&nbsp; Cookies from a jar are sent along with a request
when they are
applicable to the given request.&nbsp;&nbsp; We won't describe the
rules for cookie
applicability here, you need only know that if you use our client
functions &nbsp;to
access a site that uses cookies to implement persistence, then you
should create a <strong>cookie-jar</strong>
object and pass that same object in with each request.&nbsp;&nbsp; More
information on
cookies can be found <a
 href="http://developer.netscape.com:80/docs/manuals/js/client/jsref/cookies.htm">here</a>.</p>
<p>A <strong>cookie-jar</strong> is created with <font
 face="Courier New">(make-instance
'cookie-jar).</font></p>
<p>&nbsp;</p>
<p><strong><font face="Courier New">(cookie-jar-items&nbsp; cookie-jar)</font></strong></p>
<p>returns an alist of the cookies in the jar where each item has the
form:</p>
<p><strong>(hostname cookie-item ...)</strong></p>
<p>The <strong>hostname</strong> is a string which is matched against
the suffix of the
name of the host in the request (that is, a hostname of&nbsp; <font
 face="Courier New">".foo.com"</font>
matches <font face="Courier New">"a.foo.com"</font> and <font
 face="Courier New">"b.foo.com"</font>.
).&nbsp;&nbsp;&nbsp; The hostname should have at least two periods in
it.
&nbsp;&nbsp;&nbsp; The following <strong>cookie-item</strong> objects
in the list all
apply to that hostname. &nbsp;&nbsp; A <strong>cookie-item</strong> is
a defstruct object
and has these fields</p>
<table border="1" width="100%">
  <tbody>
    <tr>
      <th width="29%">Accessor</th>
      <th width="71%">Description</th>
    </tr>
    <tr>
      <td width="29%">cookie-item-path</td>
      <td width="71%">A string that must be the prefix of the path of
the request for it to match.&nbsp; The prefix "/" matches all paths.</td>
    </tr>
    <tr>
      <td width="29%">cookie-item-name</td>
      <td width="71%">The name of the cookie.&nbsp; A string.</td>
    </tr>
    <tr>
      <td width="29%">cookie-item-value</td>
      <td width="71%">The value of the cookie.&nbsp; A string.</td>
    </tr>
    <tr>
      <td width="29%">cookie-item-expires</td>
      <td width="71%">A string holding the time the cookie expires [in
a future release we may make this a universal time]</td>
    </tr>
    <tr>
      <td width="29%">cookie-item-secure</td>
      <td width="71%">true if this cookie should only be sent over a
secure connection.</td>
    </tr>
  </tbody>
</table>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p><a name="f-make-http-client-request"></a><strong><font
 face="Courier New">(make-http-client-request
uri &amp;key method protocol keep-alive<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
accept
cookies
headers
proxy
proxy-basic-authorization<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
basic-authorization
digest-authorization
query<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
content
content-type
content-length<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
user-agent
external-format
ssl
timeout)</font></strong></p>
<p>This function connects to the web server indicated by the <strong>uri</strong>
and
sends the request.&nbsp;&nbsp; The arguments are the same as those for <strong>do-http-request</strong>
and are documented there.&nbsp;&nbsp; There is one additional argument:
<strong>content-length</strong>.
&nbsp;&nbsp; This argument can be used to set the <strong>content-length
</strong>header
value in the request.&nbsp; After setting the content-length the caller
of <strong>make-http-client-request</strong>
would then be responsible for sending that many bytes of data to the
socket to serve as
the body of the request.&nbsp;&nbsp; If <strong>content-length </strong>is
given,
then
a
value
for
<strong>content</strong> should not be given.</p>
<p>If&nbsp; <strong>make-http-client-request</strong> succeeds in
contacting the web
server and sending a request, a <strong>client-request </strong>object
is
returned.
&nbsp;&nbsp;
If
<strong>make-http-client-request</strong> fails, then
an error is
signalled.</p>
<p>The returned <strong>client-request</strong> object contains an
open socket to a web
server, thus you must ensure that client-request object isn't discarded
before <strong>client-request-close</strong>
is called on it to close the socket and reclaim that resource.</p>
<p>After calling <strong>make-http-client-request </strong>the
program will send the body
of the request (if any), and then it will call <strong>read-client-response-headers</strong>
to partially read the web server's response to the request.</p>
<p>The default value for <strong>external-format</strong> is the value
of <strong>*default-aserve-external-format*</strong></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p><a name="f-read-client-response"></a><strong><font face="Courier New">(read-client-response-headers
client-request)</font></strong></p>
<p>This function reads the response code and response headers from the
web server.
&nbsp;&nbsp;&nbsp; After the function returns the program can use the <strong>client-request
</strong>accessors noted above to read the web server's response.&nbsp;
The body of the
response (if any) has not been read at this point.&nbsp;&nbsp;&nbsp;
You should use <strong>client-request-read-sequence</strong>
to read the body of the response part by part, or
<strong><a href="#f-read-response-body">read-response-body</a></strong>
to read it as a whole.</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p><a name="f-client-request-read-sequence"></a><strong><font
 face="Courier New">(client-request-read-sequence
buffer client-request<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&amp;key
start
end)</font></strong></p>
<p>This fills the <strong>buffer</strong> with the body of the
response from the web
server.&nbsp;&nbsp; The buffer should either be a character array or an
array of
(unsigned-byte 8).&nbsp;&nbsp;&nbsp; If given, <strong>start</strong>
specifies the index
of the <em>first</em> element in the buffer in which to store, and <strong>end
</strong>is
one plus the index of the <em>last</em> element in which to
store.&nbsp; </p>
<p>The return value is one plus the last index in the buffer filled by
this function. The
caller of the function must be prepared for having the buffer only
partially filled.
&nbsp; If the return value is zero then it indicates an End of File
condition.</p>
<p>&nbsp;</p>
<p><a name="f-read-response-body"></a><strong><font face="Courier New">(read-response-body
client-request
&amp;key
format</font></strong></p>
<p>Should only be called after <strong><a
 href="#f-read-client-response">read-client-response-headers</a></strong>
has been called. Reads the whole response body (if any) and returns
it. If the <strong>format</strong> parameter has a value of
<strong>:text</strong> (the default) the body is returned as a string,
if given <strong>:binary</strong>, it will be an array of
<strong>(unsigned-byte 8)</strong> elements. When reading text, the
external format given when creating the request is used to decode
characters.</p>
<p>&nbsp;</p>
<p><a name="f-client-request-read-close"></a><font face="Courier New"><strong>(client-request-close
client-request)</strong></font></p>
<p>The client-request object returned by make-http-request is
closed.&nbsp;&nbsp; This
returns the resources used by this connection to the operating
system.&nbsp; </p>
<p><span
 style="font-family: courier new,courier,monospace; font-weight: bold;"><br>
</span></p>
<p><span
 style="font-family: courier new,courier,monospace; font-weight: bold;"><a
 name="f-compute-digest-authorization"></a>(compute-digest-authorization
client-request
digest-authorization)<br>
<br>
</span>Given&nbsp; a client-request object after read-client-response
headers has been called on it, determine if digest authorization is
being requested and if so compute the authorization values based on the
username and password in the digest-authorization object.&nbsp; Returns
true if Digest Authorization was requested by the server and if the
authorization values were successfully computed.<br>
</p>
<p><br>
Digest authorization is more difficult since the authorization key
passed by the client is based on values passed by the server when it
rejected the request.&nbsp;&nbsp; Thus you need to make the same
request twice.&nbsp; The do-http-request function handles this retry
automatically.&nbsp;&nbsp; If you need to use
client-request-read-sequence to read the data then you will have to do
the retry as well.&nbsp;&nbsp; This function demonstrates how you use
the above functions to do the retry and then to retrieve the data:<br>
<br>
</p>
<pre>(defun getpage ()<br>  ;;<br>  ;; demonstrate how to add digest authorization to the<br>  ;; page retrieval loop that uses client-request-read-sequence<br>  ;;<br>  (let ((creq (make-http-client-request "http://www.secret.com/whatever.html")))<br>    (read-client-response-headers creq)<br>    (if* (eq 401 (client-request-response-code creq))<br>       then ; try digest authorization<br>	    (let ((da (make-instance 'digest-authorization<br>			:username "joe"<br>			:password "secret")))<br>	      (if* (compute-digest-authorization creq da)<br>		 then ; successfully computed digest authorization<br>		      ;; values<br>		      ;<br>		      ; end request<br>		      (client-request-close creq)<br>		      ; and create a new one<br>		      (setq creq (make-http-client-request <br>				  "http://www.secret.com/whatever.html"<br>				  :digest-authorization da))<br>		      (read-client-response-headers creq))))<br>    <br>    (if* (not (eql 200 (client-request-response-code creq)))<br>       then (error "get failed with code ~s"<br>		   (client-request-response-code creq)))<br>    <br>    (let ((buffer (make-array 2048 :element-type 'character)))<br>      (loop<br>	(let ((length (client-request-read-sequence buffer creq)))<br>	  (if* (zerop length)<br>	     then (return))<br>	  <br>	  (format t "got buffer of length ~s:~%~s~%" length<br>		  (subseq buffer 0 length))))<br>      <br>      (client-request-close creq))))<br><br></pre>
<p><a name="f-uriencode-string"></a>(<strong><font face="Courier New">uriencode-string&nbsp;
string
&amp;key
external-format)</font></strong></p>
<p>Convert the string into a format that would be safe to use as a
component of a url.
&nbsp;&nbsp;&nbsp; In this conversion most printing characters are not
changed
&nbsp;&nbsp; All non printing characters and printing characters that
could be confused
with characters that separate fields in a url are encoded a %xy where
xy is the
hexadecimal representation of the char-code of the
character.&nbsp;&nbsp; <br>
external-format defaults to the value of <strong>*default-aserve-external-format*</strong>.</p>
<hr>
<h2><a name="proxy"></a>Proxy</h2>
<p>AllegroServe can serve as an http proxy.&nbsp;&nbsp; What this means
is that web
clients can ask AllegroServe to fetch a URL for them.&nbsp;&nbsp; The
two primary uses for
a proxy server are </p>
<ol>
  <li>you have web clients on a local network and you would prefer that
the web clients don't send messages out to the internet.&nbsp;&nbsp;
You run AllegroServe on a machine that has access both to the internal
network and to the internet.&nbsp; You then configure the web clients
to proxy through AllegroServe (directions for doing this are given
below).</li>
  <li>You wish to use AllegroServe's caching facility to store copies
of pages locally to improve responsiveness.&nbsp; In this case you must
start AllegroServe as a proxy server for the web clients who will use
the cache.</li>
</ol>
<p>In order to run AllegroServe as a proxy server you should specify <strong>:proxy
t</strong>
in the arguments to the <strong>net.aserve:start</strong>
function.&nbsp;&nbsp; With this
specified AllegroServe will still act as a web server for pages on the
machine on which
AllegroServe is running.&nbsp; AllegroServe will act as a proxy for
requests to other
machines.</p>
<p>Each web browser has it's own way of specifying which proxy server
it should use.
&nbsp; For Netscape version 4 select the <strong>Edit</strong> menu,
then <strong>Preferences..</strong>.
and then click on the <strong>plus sign</strong> to the left of <strong>Advanced</strong>.
&nbsp;
Then
select
<strong>Proxies</strong> and click on&nbsp; <strong>Manual
Proxy
Configuration</strong> and the click on <strong>View</strong> and
specify the name of the
machine running AllegroServe and the port number on which AllegroServe
is listening.
&nbsp; Then click <strong>OK</strong> on all the dialog boxes.</p>
<p>For Internet Explorer 5 select the <strong>Tools</strong> menu, and
then <strong>Internet
Options..</strong> and then the <strong>Connections</strong> tab, and
then <strong>LAN
Settings</strong>.&nbsp;&nbsp; Click on <strong>Use a Proxy Server </strong>and
then
click
on
<strong>Advanced</strong> and specify the machine name and port
number for
AllegroServe.&nbsp; Then click on <strong>OK</strong> to dismiss the
dialog windows.</p>
<p>&nbsp;</p>
<hr>
<h2><a name="cache"></a>Cache</h2>
<p>The AllegroServe cache is a facilty in development.&nbsp; We'll
describe here the
current status of the code. </p>
<p>The cache consists of a memory cache and a set of zero or more disk
caches.
&nbsp;&nbsp;&nbsp;&nbsp; Items initially live in the memory cache and
are moved to the
disk caches when the memory cache fills up.&nbsp;&nbsp; Items enter the
memory cache due
to a page being accessed via the proxy server.&nbsp;&nbsp; Items in the
disk cache move
back to the memory cache if the data portion must be sent back to the
requesting client
(some requests can be answered without sending back the contents of the
page and for these
the item stays in the disk cache).</p>
<p>You specify the sizes of each cache.&nbsp;&nbsp; The disk caches
will never grow beyond
the size you specified but the memory cache can exceed the specified
size for a short
time.&nbsp; A background thread moves items from the memory cache to
the disk caches and
we will allow you to control how often that thread wakes up and ensures
that the memory
cache is within the desired constraints.</p>
<p>When <strong>net.aserve:start</strong> is called you specify if you
want caching and if
so what size caches you want.&nbsp;&nbsp; A sample argument pair passed
to <strong>net.aserve:start</strong>
is</p>
<pre>:cache '(:memory 10000000 :disk ("/tmp/mycache" 30000000) :disk (nil 20000000))</pre>
<p>This says that the memory cache should be 10,000,000 bytes and that
there should be two
disk caches.&nbsp;&nbsp; One disk cache is the file "/tmp/mycache" and
can grow
to 30,000,000 bytes and the other cache will have a name chosen by
AllegroServe and it can
grow to 20,000,000 bytes.&nbsp;&nbsp; We should note here that one
thing that
distinguishes the AllegroServe caching facilty from that found in many
other http
proxy-caches is that AllegroServe uses a few&nbsp; large cache files
rather than storing
each cached item in a separate file in the filesystem.&nbsp;&nbsp; </p>
<p>A few other ways of specifying caching at startup is:</p>
<pre>:cache t</pre>
<p>This will create a memory case of the default size (currently 10
megabytes) and it will
create no disk caches.</p>
<pre>:cache 20000000</pre>
<p>This will create a memory cache of 20,000,000 byte and no disk
caches.</p>
<p>&nbsp;</p>
<p>When caching is enabled we publish two links to pages showing cache
information.
&nbsp;&nbsp; This is useful during debugging and is likely to change in
the future. &nbsp;
The two pages are&nbsp; <strong>/cache-stats</strong>&nbsp; and&nbsp; <strong>/cache-entries</strong>.</p>
<p>&nbsp;</p>
<hr>
<h2><a name="filters"></a>Request Filters</h2>
<p>After AllegroServe reads a request and before it checks the locators
to find an entity
to handle the request, AllegroServe runs the request through a set of
filters. </p>
<blockquote>
  <p>A filter is a function of one argument: the http-request object.
The filter examines and possibily alters the request object. The idea
is that filters can do large scale and simple url rewriting, such as
changing all requests for one machine to another machine. The filtering
occurs before the test to see if this is a proxy request so a filter
can change a proxy request to a non proxy request or vice versa. </p>
  <p align="left">The currently active filters are found in two
places.&nbsp; First the <strong>vhost-filters</strong> function of the
applicable <strong>vhost</strong> returns a set of <strong>vhost</strong>
specific filters.&nbsp;&nbsp; Next the <strong>wserver-filters</strong>
function on the current <strong>wserver</strong> object returns a set
of server global filters. &nbsp;&nbsp;&nbsp; Both of these functions
are <strong>setf</strong>'able to change the set of filters.</p>
</blockquote>
<p>&nbsp;</p>
<p>A filter function returns <strong>:done</strong> if no more filters
should be run after
this one. If the filter returns anything else then subsequent filters
in the list are run
as well.&nbsp;&nbsp; If a filter in the <strong>vhost</strong> list
returns <strong>:done</strong>
then the server global filters are not even checked.</p>
<p>When a filter function runs it's most likely going to be looking at
two slots in the
request object, which are accessed via these functions: </p>
<ul>
  <li><strong>request-raw-uri </strong>- the actual uri given in the
http command </li>
  <li><strong>request-uri</strong> - a constructed uri starting with
the raw uri and adding information from the Host header field. This
value is used to find the entity to run thus it has all the information
about the request. </li>
</ul>
<p>Also the value of <font face="Courier New">(header-slot-value
request :host)</font> is
important to check and possibly change. </p>
<p>If the browser is setup to access the internet directly then a
request from the user
for <br>
&nbsp;&nbsp;&nbsp; <strong>http://foo.bar.com:23/whatever<br>
</strong><br>
will cause the request to be sent to the server at <strong>foo.bar.com
</strong>port 23
and the request will have: </p>
<ol>
  <li>the request-raw-uri is <strong>/whatever </strong></li>
  <li>the request-uri is <strong>http://foo.bar.com:23/whatever </strong></li>
  <li>the Host header value is <strong>"foo.bar.com:23" </strong></li>
</ol>
<p><br>
<br>
<br>
If the browser is setup to send all requests through a proxy at <strong>proxy.blop.com</strong>
then a request for <br>
<strong>http://foo.bar.com:23/whatever </strong><br>
will come to <strong>proxy.blop.com</strong> and will have a different
raw uri: </p>
<ol>
  <li>the request-raw-uri is now <strong>http://foo.bar.com:23/whatever









    </strong></li>
  <li>the request-uri is still <strong>http://foo.bar.com:23/whatever </strong></li>
  <li>the Host header value is still <strong>"foo.bar.com:23" </strong></li>
</ol>
<p>If the filter wants to alter the destination of request it should
ensure that the three
values mentioned above are set appropriately for the destination. If
the new destination
is not served by the current Allegroserve wserver, then the filter will
have to make sure
to turn it into a proxy request (and this will only work if this
AllegroServe was started
with proxying enabled).</p>
<p>&nbsp;</p>
<hr>
<h2><a name="virtual_hosts"></a>Virtual Hosts</h2>
<p>It is possible for a single web server to act like two or more
indepenent web servers.
&nbsp; This is known as <em>virtual hosting</em>.&nbsp; AllegroServe
supports the ability
to run any number of virtual hosts in a single instance of AllegroServe.</p>
<p>AllegroServe runs on a single machine and listens for requests on
one port on one or
more more IP addresses.&nbsp;&nbsp; When a request arrives there is
usually a header line
labelled <font face="Courier New">Host</font> whose value is the
specific hostname typed
into the browser by the user.&nbsp;&nbsp; Thus if hostnames <font
 face="Courier New">www.foo.com</font>
and <font face="Courier New">www.bar.com </font>both point to the
same machine then it's
possible for the webserver on that machine to distinguish a request for
<font face="Courier New">http://www.foo.com</font> from a request for <font
 face="Courier New">http://www.bar.com</font>
by looking at the <font face="Courier New">Host</font> header.</p>
<p>In order to make AllegroServe easy to use you can ignore the virtual
hosting facility
until you plan to use it.&nbsp;&nbsp; As long as you don't specify a <strong>:host</strong>
argument to any of the publish functions when adding content to your
site, everything you
publish will be visible from your web server no matter which hostname
the web browser uses
to access your site.&nbsp; If you decide you want to make use of
virtual hosting, then
read on.</p>
<h3>vhost class</h3>
<p>In AllegroServe a virtual host is denoted by an instance of class <strong>vhost</strong>.
&nbsp;&nbsp;
The
contents
of
a
vhost
object
are:</p>
<table border="1" width="83%">
  <tbody>
    <tr>
      <th width="26%">Accessor Function</th>
      <th width="57%">What</th>
      <th width="17%">initarg</th>
    </tr>
    <tr>
      <td width="26%">vhost-log-stream</td>
      <td width="57%">Stream to which to write logging information on
requests to this virtual host</td>
      <td width="17%"><strong>:log-stream</strong></td>
    </tr>
    <tr>
      <td width="26%">vhost-error-stream</td>
      <td width="57%">Stream to which AllegroServe sends informational
and error messages that are generated during request processing.</td>
      <td width="17%"><strong>:error-stream</strong></td>
    </tr>
    <tr>
      <td width="26%">vhost-names</td>
      <td width="57%">A list of all the names for this virtual
host.&nbsp; </td>
      <td width="17%"><strong>:names</strong></td>
    </tr>
    <tr>
      <td width="26%">vhost-filters</td>
      <td width="57%">list of <a href="#filters">filter functions</a> </td>
      <td width="17%"><strong>:filters</strong></td>
    </tr>
  </tbody>
</table>
<p>The defaults values for the two streams in a vhost object is the <strong>wserver-log-stream</strong>
from the server object.</p>
<p>Every instance of AllegroServe has a default vhost object that can
be retrieved from
the <strong>wserver </strong>object via the function <strong>wserver-default-vhost.
&nbsp;&nbsp;
</strong>If a request comes in for a virtual host that's
not known, then it's
assumed to be for the default virtual host.</p>
<p>There are two ways to create virtual hosts in AllegroServe:
implicitly or explicitly.
&nbsp;&nbsp; If a publish function is called with a <strong>:host</strong>
value that
names a host not known to be a virtual host then a <strong>vhost</strong>
instance will be
created automatically and stored in the <strong>wserver</strong>'s
hash table that maps
names to <strong>vhost </strong>objects.&nbsp; This is implicit
virtual host creation.</p>
<p>If you know ahead of time the virtual hosts you'll be serving then
it's better to setup
all the virtual hosts explicitly.&nbsp;&nbsp; You create a <strong>vhost</strong>
instance
with <strong>make-instance</strong> and you register each virtual host
in the <strong>wserver-vhosts</strong>
table using <strong>gethash.</strong>&nbsp;&nbsp;&nbsp;&nbsp;
Following is an example of
setting up a server to have two virtual hosts, one that responds to
three names and one
that responds to two names.&nbsp;&nbsp; Since we are using the default
vhost to represent
the first virtual host, this virtual host will also receive requests
for names we haven't
mentioned explicitly.</p>
<p>&nbsp;</p>
<pre>(defun setup-virtual-hosts (server)<br>  (let ((vhost-table (wserver-vhosts server))<br>	(foo-names '("localhost" "www.foo.com" "foo.com"))<br>	(bar-names '("www.bar.com" "store.bar.com")))<br>    <br>    (let ((default-vhost (wserver-default-vhost server)))<br>      (setf (vhost-names default-vhost) foo-names)<br>      (dolist (name foo-names)<br>	(setf (gethash name vhost-table) default-vhost)))<br>    <br>    (let ((bar-vhost (make-instance 'vhost :names bar-names)))<br>      (dolist (name bar-names)<br>	(setf (gethash name vhost-table) bar-vhost)))))<br><br></pre>
<p>When a request comes in, AllegroServe will determine which vhost is
the intended target
and if none is found it will select the default vhost as the intended
target.&nbsp; The
vhost so determined will be stored in the<strong> http-request </strong>object
in
the
slot
accessed
by
<strong>request-vhost</strong> function.</p>
<h3><a name="host_arg"></a>host argument to publish functions</h3>
<p>We now are in a position to describe what values the <strong>:host</strong>
argument to
the publish functions can take on.&nbsp;&nbsp; The <strong>:host</strong>
argument can be <strong>nil</strong>
or one of: </p>
<ol>
  <li>a string naming a virtual host.&nbsp; If there is no virtual host
with this name a new virtual host object is created. </li>
  <li>a vhost object</li>
  <li>the symbol <strong>:wild</strong></li>
  <li>a list of items of the above items</li>
</ol>
<p>If the value of the <strong>:host </strong>argument is <strong>nil</strong>,
then
its
value
is
assumed
to
be
<strong>:wild</strong>.</p>
<p>The value of the <strong>:host </strong>argument is converted into
a list of one or
more vhost objects and/or the symbol <strong>:wild.</strong>&nbsp;&nbsp;&nbsp;
The
meaning
of
a
vhost
is
clear:
it
means
that
this entity will be visible on this
virtual host.
&nbsp; The meaning of <strong>:wild </strong>is that this entity will
be visible on <em>all</em>
virtual hosts, except it can be shadowed by an entity specified for a
particular virtual
host.&nbsp; Thus you could publish an entity for<strong> :path "/" </strong>and
<strong>:host
:wild</strong> and it will be used for all virtual hosts that don't
specify an entity for <strong>:path
"/"</strong>.&nbsp; Note that when a request comes in and the search is
done for
an entity to match the request every step of the way we look first for
a vhost specific
handler and then a <strong>:wild</strong> handler&nbsp;&nbsp; It is <em>not</em>
the case
that we first do a complete search for a vhost specific handler and
then restart the
search this time looking for a <strong>:wild</strong> handler.</p>
<p>&nbsp;</p>
<hr>
<h2><a name="timeouts"></a>Timeouts</h2>
<p>A web server is a program that provides resources to a client
program
connecting over the
network.&nbsp; The resources a web server has to offer is limited and
it's important that
network problems or buggy clients don't cause those resources to be
unavailable to new
clients.&nbsp;&nbsp; AllegroServe uses timeouts to ensure that no
client can hold a web
server resource for more than a certain amount of time.</p>
<p>Three common ways for a resource to be held are </p>
<ol>
  <li>A client stops sending a request in the middle of the
request.&nbsp;&nbsp; This can happen if the client machine crashes
or&nbsp; if the client's machine loses network connectivity with
the&nbsp; machine running AllegroServe.</li>
  <li>A client stops reading the response to its
request.&nbsp;&nbsp;&nbsp; The networking code will automatically stop
the sender from writing new data if the receiver has a lot of existing
data to read. </li>
  <li>The response function to an http request can take a very long
time, or may even be in an infinite loop.&nbsp;&nbsp; This could be due
to a bug in a http response function or something unexpected, like a
database query taking a long time to finish.</li>
</ol>
<p>&nbsp;</p>
<h3>Acl 6.0 or older</h3>
<p>For AllegroServe running in Acl 6.0 or <em>older</em> timeouts are
done this way:</p>
<p><strong>net.aserve::*read-request-timeout*</strong>&nbsp; - number
of seconds
AllegroServe allows for the request line (the first line) and all
following header lines.
&nbsp; The default is 20 seconds.</p>
<p><strong>net.aserve::*read-request-body-timeout* </strong>- number
of seconds
AllegroServe allows for the body of the request (if any) to be
read.&nbsp;&nbsp; The
default is 60 seconds.</p>
<p><strong>(wserver-response-timeout wserver)</strong> - the number of
seconds
AllegroServe allows for an http request&nbsp; function to be run and
finished sending back
its response.&nbsp; The initial value for this slot of the wserver
object is found in <strong>*http-response-timeout*
</strong>which defaults to 120 seconds.&nbsp; You can alter this
timeout value with the <strong>:timeout</strong>
argument to <strong>with-http-response</strong> or by specifying a <strong>:timeout</strong>
when publishing the entity.</p>
<h3>Acl 6.1 or newer</h3>
<p>In Acl 6.1 we added the capability of having each I/O operation to a
socket stream time
out.&nbsp;&nbsp; This means that we don't have to predict how long it
should take to get a
request or send a response.&nbsp; As long as we're making progress
reading or writing we
know that the client on the other end of the network connection is
alive and well.
&nbsp;&nbsp; We still need a timeout to handle case (3) above but we
can allow a lot more
time for the http response since we aren't using this timer to catch
dead clients as well.
&nbsp;&nbsp; Thus we have these timeout values:</p>
<p><a name="f-wserver-io-timeout"></a><strong>(wserver-io-timeout
wserver)</strong> - the
number of seconds that AllegroServe will wait for any read or write
operation to the
socket to finish.&nbsp;&nbsp; The value is initialized to the value of
*http-io-timeout*
&nbsp; which defaults to 60 seconds.</p>
<p><a name="f-wserver-response-timeout"></a><strong>(wserver-response-timeout
wserver)</strong>
-&nbsp; the number of seconds AllegroServe allows for an http request
function to be run
and finished sending back its response. The initial value for this slot
of the wserver
object is found in <strong>*http-response-timeout*</strong> which
defaults to 300 seconds.
You can alter this timeout value with the :timeout argument to <strong>with-http-response</strong>
or by specifying a <strong>:timeout </strong>argument to the publish
function creating the
entity.</p>
<p><strong>publish-directory </strong>and <strong>publish-file </strong>default
their
<strong>timeout</strong>
argument in a way that makes sense based on whether the Lisp supports
I/O timeouts.
&nbsp;&nbsp; If I/O timeouts are supported then there is no reason to
do a global timeout
for the whole response if you're just sending back a file.&nbsp;&nbsp;
Thus in this case
the <strong>timeout</strong> argument defaults to a huge number.</p>
<p>&nbsp;<br>
</p>
<hr style="width: 100%; height: 2px;">
<h2><a name="compression"></a>Compression</h2>
<p>The HTTP protocol allows the client to request an entity be returned
by the server.&nbsp;&nbsp; The server can simply send that entity as is
or the client and server an agree that an encoded version of the entity
should be transported.&nbsp; The server does the encoding, the client
does the decoding and the caller of the client gets what it expects and
is totally unaware that the entity was encoded while being transported.</p>
<p>The encoding supported by AllegroServer is called gzip.&nbsp;&nbsp;
Gzip is a compression algorithm.&nbsp;&nbsp;&nbsp; A gziped text file
can be substantially smaller than the original.&nbsp;&nbsp;&nbsp; gzip
will not shink (and it may even grow) files that already compressed
such as image files (jpeg, gif, png), movie files (mp4, mov, avi). or
compressed archive file (zip, tar.gz, tgz).<br>
</p>
<p>The are two types of compression handled by AllegroServe<br>
</p>
<ol>
  <li>on the fly compression -&nbsp; when a computed entity is
generated AllegroServe can compress the generated entity as it is being
generated.&nbsp; <br>
  </li>
  <li>static file compression - if a web site contains files that might
compress well the webmaster can arrange to compress those files and
leave the compressed version of those files on the web site as well for
AllegroServe to find.</li>
</ol>
One action that AllegroServe will never take is to compress a static
file on the fly. <br>
<br>
In order for AllegroServe to encode an entity's body using gzip
compression the following must be true<br>
<ol>
  <li>The server must be started with :compress t.&nbsp;&nbsp;
Alternatively the enable-compression slot of the *wserver* object must
be true.&nbsp; This slot is&nbsp; a server wide switch that controls
whether compressed encodings are sent from the server.</li>
  <li>The client request must include a header "Accept-Encoding: gzip"</li>
  <li>The entity being published must have be specified with ":compress
t".&nbsp;&nbsp;</li>
  <li>The zlib compression library must be on the server machine.<br>
  </li>
</ol>
If the entity is computed then the above four conditions are enough to
cause a compressed result to be sent.&nbsp; If the entity is a file
entity (perhaps created due to a directory entity being searched) then
you also need<br>
<ol>
  <li>a compressed version of the file (the same file name but with
".gz" appended)</li>
  <li>the compressed version must be as young or younger than the
original version (comparing last modified times).</li>
</ol>
The only way to tell if a compressed version was sent in place of the
original version is to note a smaller number of bytes transmitted as
recorded in the log file.<br>
<hr style="width: 100%; height: 2px;"><br>
<br>
<h2><a name="ssltls"></a>SSL/TLS</h2>
<br>
The SSL protocol used for secure communcation has gone through a
sequence of revisions. The public revisions are SSL v2.0, SSL v3.0 and
SSL v3.1.&nbsp; There was a renaming as well so SSL v3.1 is officially
known as TLS v1.0.<br>
&nbsp;&nbsp;&nbsp; <br>
When an SSL client connects to an SSL server they will communicate
using the most recent protocol that both support.<br>
&nbsp;&nbsp;&nbsp; <br>
By default AllegroServe's SSL server and client declare that they are
willing to communicate using SSL v2.0, v3.0 or v3.1 (TLS v1.0). If you
wish to restrict the server or client to a particular protocol you can
pass the <span style="font-weight: bold;">:ssl-method</span> argument
to <span style="font-weight: bold;">net.aserve:start</span> or <span
 style="font-weight: bold;">net.aserve.client:do-http-request</span>.&nbsp;&nbsp;
At
present
the
only
meaningful
value
you
would want to pass is <span style="font-weight: bold;">:tlsv1</span>
meaning that you only want to
communicate using TLS v1.0 (SSL v3.1), the most modern and secure of
the protocols.<br>
<br>
<hr>
<h2><a name="miscellaneous"></a>Miscellaneous</h2>
<p><a name="f-ensure-stream-lock"></a><strong><font face="Courier New">(ensure-stream-lock
stream)</font></strong></p>
<p>The function adds a <a
 href="http://www.franz.com/support/documentation/6.1/doc/multiprocessing.htm#process-locks-1">process
lock</a> to <strong>stream</strong>'s property list (under the
indicator<strong> :lock</strong>)
if no such lock is present.&nbsp;&nbsp; Then it returns the object <strong>stream</strong>.</p>
<p>The AllegroServe logging functions make use of the stream's lock to
ensure that only
one thread at a time write log information to the stream.&nbsp;&nbsp;
If the logging
functions find that a a log stream doesn't have a lock associated with
it then the log
information will still be written to the stream but under heavy load
the log information
from multiple threads will become intermixed. </p>
<p>&nbsp;</p>
<p><a name="f-map-entities"></a><font face="Courier New"><strong>(map-entities
function
locator)</strong></font></p>
<p>When<strong> </strong>one of the<strong> </strong>publish
functions is called entities
are placed in <em>locator<strong> </strong></em>objects.&nbsp;&nbsp;
The locator objects
are then checked when http requests come in to find the appropriate
entity.&nbsp; <strong>map-entities</strong>
will apply the given <strong>function</strong> of one argument to all
the entities in the
given<strong> locator</strong>.&nbsp;&nbsp; One common use of <strong>map-entities</strong>
is to find entities that you no longer wish to be published.&nbsp; For
that reason <strong>map-entities</strong>
will remove the entity&nbsp; passed to the <strong>function</strong>
if
the <strong>function</strong>
returns the keyword symbol <strong>:remove</strong> as its value.</p>
<p>&nbsp;</p>
<p><a name="f-log-for-wserver"></a><font face="Courier New"><strong>(log-for-wserver
wserver
message
format)</strong></font></p>
<p>This is a method that is called by AllegroServe whenever it wants
to log something. The <code>wserver</code> argument can be specialized
on for your own server class, in order to make log messages go to your
own log stream, formatted using your own logging conventions.
<code>message</code> will always be a string, and <code>format</code>
can be one of <code>:long</code> or <code>:brief</code>, which
AllegroServe itself uses to distinguish between messages that get a
full date timestamp, and those that get only a time. Your custom
method can choose to ignore this if it doesn't support multiple levels
of verbosity.</p>
<p>&nbsp;</p>
<hr>
<h2><a name="asaservice"></a>Running AllegroServe as a Service on
Windows NT</h2>
<p>On Windows NT (and Windows 2000 and Windows XP) when you log off all
the programs you
are running are terminated.&nbsp;&nbsp; If you want to run AllegroServe
on your machine
after you log out you have to start it as a <strong>Windows
Service.&nbsp; </strong>This
is easy to do thanks to code contributed by Ahmon Dancy.&nbsp;&nbsp; </p>
<p>The first step is to download the <a
 href="http://opensource.franz.com/ntservice">ntservice
code and documentation</a> from the Franz <a
 href="http://opensource.franz.com">opensource
site</a>.&nbsp; Read the documentation carefully especially as regards
the different
capabilities of the accounts under which you may choose to run
AllegroServe.&nbsp;&nbsp; </p>
<p>You'll probably want to build an AllegroServe application that can
run either normally
or as a service,.&nbsp; You can run it normally to debug it and then
start it as a service
when you're satisfied that it works.</p>
<p>Following is an example of how this can be done.&nbsp;&nbsp; I've
decided that if the <font face="Courier New">/service</font> argument
is given on the command line when I start my
application then I'll start my application as a service, otherwise I
start it normally.
&nbsp;&nbsp;&nbsp;&nbsp; Here is the <strong>restart-init-function</strong>
(to <strong>generate-application</strong>)
that I define:</p>
<pre>(defun start-aserve-application ()<br>  (flet ((start-application ()<br>	   (net.aserve:start :port 8020)<br>	   (loop (sleep 100000))))<br>    (if* (member "/service" (sys:command-line-arguments) :test #'equalp)<br>     then ; start as  a service<br>	  (ntservice:start-service #'start-application)<br>     else ; start as a normal app<br>	  (start-application)))))</pre>
<p>&nbsp;</p>
<p>I use <font face="Courier New">(loop (sleep 100000))</font> to
ensure that the <strong>restart-init-function</strong>
never returns.</p>
<p>&nbsp;</p>
<p>In order to register my application as a service to the operating
system I call <strong>ntservice:create-service</strong>
like this:</p>
<pre>(ntservice:create-service "aservetest" "Aserve Test Service"<br>     "c:\\acl62\\testservice\\testapp\\testapp.exe -- /service")</pre>
<p>Note that I use "<font face="Courier New">--</font>" before the "<font
 face="Courier New">/service</font>".&nbsp; This is <em>very </em>important.
&nbsp;&nbsp;
The
"<font face="Courier New">--</font>" separates the
arguments
used to start up the program from the arguments passed to the program
itself. &nbsp;&nbsp;
The call to <strong>ntservice:create-service</strong> is done only
once and need not be
done from within your application.&nbsp; </p>
<p>Once an application is registered as a service you can start it by
going to the Control
Panel, selecting Administrative Tools and then Services.&nbsp;&nbsp;
Locate the service
you just added, right click on it and select <strong>start</strong>.&nbsp;&nbsp;
You
can
stop
the
service
with&nbsp;
a
right
click
as
well. </p>
<p>&nbsp;</p>
<hr>
<h2><a name="international-chars-aserve"></a>Using International
Characters in
AllegroServe</h2>
<p>A <em>character set</em> is a collection of characters and a rule
to encode them as a
sequence of octets.&nbsp;&nbsp; The default character set for web
protocols is Latin1
(also known as ISO 8859-1).&nbsp;&nbsp; The Latin1 character set
represents nearly every
character and punctuation needed for western European languages (which
includes English).
&nbsp;&nbsp; </p>
<p>If you want to work with characters outside the Latin1 set you'll
want to use the <a
 href="http://www.franz.com/support/documentation/6.1/doc/iacl.htm">International
version
of
Allegro
CL</a> which represents characters internally by their
16-bit <a href="http://www.unicode.org">Unicode</a>
value.&nbsp;&nbsp;&nbsp; In this section we'll
assume that you're using International Allegro CL.</p>
<p>What the web protocols refer to as <strong>charset</strong>
(character set) Allegro CL
refers to as an <strong>external-format</strong>.&nbsp; Allegro CL
uses a different term
since it always uses 16-bit Unicode to represent characters
internally.&nbsp; 16 bit
unicode can represent nearly all characters on the planet.&nbsp; It's
only when those
characters are read from or written to devices outside of Lisp that the
actual encoding of
those characters into octets matters.&nbsp;&nbsp;&nbsp; Thus the <strong>external-format</strong>
specifies how characters are encoded and specifies which Unicode
characters are part of
the character set that the external-format defines.&nbsp; Attempts to
write a Unicode
character that's not part of the character set results in a question
mark being written.</p>
<p>External-formats are also used in Allegro CL to do certain character
to character
transformations.&nbsp; In particular on the Windows platform external
formats are used to
convert the lisp end of line (a single #\newline character) to the
#\return #\linefeed
character that is standard on Windows.&nbsp;&nbsp; Thus an external
format such as <strong>:utf-8</strong>
&nbsp; has a different effect on Windows than on Unix, and this is not
desirable for web
applications.&nbsp;&nbsp; The function call <font face="Courier New">(crlf-base-ef&nbsp;:utf-8)</font>
returns an external format on Windows and on Unix that simply does the
character encoding
part of the external format, and thus this is the external format you
would want to use in
a web application.</p>
<h3>server to client (browser) character transfer</h3>
<p>When a web server returns a response to a client it sends back a
response line, a
header and optionally a body.&nbsp;&nbsp; The response line and header
are always sent
using a subset of the Latin1 character set (the subset corresponding
the&nbsp; US ASCII
character set).&nbsp;&nbsp; The body is sent using the full Latin1
character set, unless
otherwise specified.&nbsp; To specify the character set of the body you
add an extra
parameter to the Content-Type header.&nbsp;&nbsp; Instead of specifying
a content type of
"text/html" you might specify "text/html;&nbsp;charset=iso-8859-2".
&nbsp;&nbsp; This alerts the http client that it must interpret the
octets comprising the
body of the response according to the iso-8859-2 character
set.&nbsp;&nbsp; This however
is <em>not<strong> </strong></em>enough to make AllegroServe encode
the Unicode characters
it's sending to the client using the approrpriate external
format.&nbsp; You would have to
do this:</p>
<pre>(with-http-response (req ent)<br>  (with-http-body (req ent :external-format (crlf-base-ef :iso8859-2))<br>     ... generate and write page here..<br>))</pre>
<p>Note that the charset names and external format name are similar but
not identical.
&nbsp; Check <a href="http://www.iana.org/assignments/character-sets">here</a>
for the
charset names and check <a
 href="http://www.franz.com/support/documentation/6.1/doc/iacl.htm#external-formats-1">here</a>
for the Allegro CL external format names.</p>
<p>In order to make it easier to specify external formats in
AllegroServe you can specify
a default external format when you start the server (with the <strong>:external-format</strong>
argument to the <strong>start</strong> function).&nbsp;&nbsp; The
variable <strong>*default-aserve-external-format*
</strong>will then be bound to this external format in each of the
threads that processes
http requests.&nbsp;&nbsp; It's the value of <strong>*default-aserve-external-format*</strong>
that is used as the default argument to the :external-format argument
to <strong>with-http-body</strong>.</p>
<p>The default value of the <strong>:external-forma</strong>t argument
to the <strong>start</strong>
function, and thus the default value of *<strong>default-aserve-external-format*</strong>,
is
<strong>(crlf-base-ef :latin1-base</strong>).&nbsp;&nbsp; This
means that regardless of
the locale in which you run AllegroServe, AllegroServe will by default
use the Latin1
character set, which is what is expected by web clients..</p>
<p>A very useful character set is <strong>utf-8</strong> which is the
whole Unicode
character set and thus comprises all of the characters you can store
inside Lisp.
&nbsp;&nbsp; The corresponding Allegro CL external format is the value
of <font face="Courier New"><strong>(crlf-base-ef :utf-8)</strong></font>.&nbsp;&nbsp;
Specifying
this
character
set
allows
you
to
write
web
pages
that can use
characters
from nearly every
language in the world (whether the web browser can find the glyphs to
display all those
characters is another matter). </p>
<h3>client (browser) to server character transfer</h3>
<p>The brower sends characters to the web server when the user enters
data into a form and
submits the form.&nbsp;&nbsp; The important thing to remember is that
the browser will
encode characters using the character set that was specified for the
web page containing
the form.&nbsp; If you fail to specify a <strong>charset</strong> when
the page was given
to the web browser then the web browser will decide on its own how to
encode characters
that aren't part of the default character set ( which is of course
Latin1). &nbsp;&nbsp;
The browser will <em>not</em> tell you which encoding it chose. &nbsp;
Therefore if you
ever plan on allowing&nbsp; non-Latin1 characters to be specified in
your forms you'll
want to specify a <strong>charset</strong> for the page containing the
form. </p>
<p>You can specify the charset in the Content-Type field of the header
that's sent with
the page (as we described above) or you can put it in the page itself
using a meta tag:</p>
<pre>&lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8"&gt;</pre>
<p>Retrieving form data in AllegroServe is done with the <strong>request-query</strong>
function and that function takes an <strong>:external-format</strong>
argument so you can
specify how the form data can be decoded.&nbsp;&nbsp; If your form
sends multipart data
then you can use the <strong>:external-format</strong> argument to <strong>get-multipart-sequence</strong>
to retrieve the form data and decode the data.</p>
<h3>examples</h3>
<p>The AllegroServe test page has links to a few pages that show how
international
characters work with AllegroServe.&nbsp; One of these is&nbsp; the
International Character
Display page.&nbsp; This page&nbsp; shows what happens when the <strong>charset</strong>
and <strong>external-format</strong> are set to different values and a
page containing
international characters is displayed.&nbsp; It demonstrates how it
important it is that
those two character set specifications be kept in sync, and it shows
that <strong>utf-8</strong>
is most likely the best choice for a character set for your web pages.</p>
<p>&nbsp;</p>
<hr>
<h2><a name="debugging"></a>Debugging</h2>
<p>Debugging entity handler functions is difficult since these are
usually run on a
separate lisp thread.&nbsp; Also AllegroServe catches errors in entity
handler functions,
thus preventing you from interactively diagnosing the problem.</p>
<p>You can put AllegroServe in a mode that makes debugging easier with
the <font face="Courier New">net.aserve::debug-on</font>
function.&nbsp;&nbsp; Note that this is not
an exported function to emphasize the fact that you are working with
the internals of
AllegroServe.</p>
<p>&nbsp;</p>
<p><a name="f-debug-on"></a><strong><font face="Courier New">(net.aserve::debug-on
&amp;rest
debugging-features-to-enable)</font></strong></p>
<p>We've classified the debugging features and given each a keyword
symbol name.
&nbsp;&nbsp; This function turns on those named features.&nbsp; If no
arguments are given,
then <strong>debug-on</strong> prints the list of debugging features
and whether each is
enabled.</p>
<p>&nbsp;</p>
<p><a name="f-debug-off"></a><strong><font face="Courier New">(net.aserve::debug-off
&amp;rest
debugging-features-to-disable)</font></strong></p>
<p>This function turns off the given list of features.</p>
<p>&nbsp;</p>
<p>The list of debug features are:</p>
<table border="1" width="100%">
  <tbody>
    <tr>
      <td width="18%"><strong>:info</strong></td>
      <td width="82%">AllegroServe prints information at certain places
while doing its processing. &nbsp; </td>
    </tr>
    <tr>
      <td width="18%"><strong>:xmit</strong></td>
      <td width="82%">AllegroServe prints what it receives from and
sends to the client.&nbsp; In some cases the body of a request or
response will not be printed.</td>
    </tr>
    <tr>
      <td width="18%"><strong>:notrap</strong></td>
      <td width="82%">When enabled, this prevents AllegroServe from
catching errors in entity handler functions.&nbsp; If an error occurs
and you're running in an evironment where background processes
automatically create new windows (such as the emacs-lisp interface)
then you'll be given a chance to :zoom the stack and diagnose the
problem.&nbsp; Note that if a timeout has been established to limit the
amount of time that a certain step is allowed (and this is done by
default) then the interactive debugging session will be aborted when
the timeout is reached.</td>
    </tr>
  </tbody>
</table>
<p>&nbsp;</p>
<p>Two pseudo debug features are <strong>:all</strong> and <strong>:log.</strong>.
&nbsp;
Specifying
<strong>:all </strong>to <strong>debug-on</strong> or <strong>debug-off</strong>
&nbsp; is the same as listing all of the debug features.&nbsp;&nbsp;
Specifying <strong>:log</strong>
is the same as specifying all features except <strong>:notrap.</strong></p>
<p>&nbsp;</p>
</body>
</html>
